/* Sequence.c generated by valac 0.34.4, the Vala compiler
 * generated from Sequence.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <plank.h>
#include <gio/gio.h>
#include <float.h>
#include <math.h>
#include <signal.h>
#include <sys/types.h>
#include <gobject/gvaluecollector.h>


#define CAPTURE_TYPE_SEQUENCE (capture_sequence_get_type ())
#define CAPTURE_SEQUENCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CAPTURE_TYPE_SEQUENCE, CaptureSequence))
#define CAPTURE_SEQUENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CAPTURE_TYPE_SEQUENCE, CaptureSequenceClass))
#define CAPTURE_IS_SEQUENCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CAPTURE_TYPE_SEQUENCE))
#define CAPTURE_IS_SEQUENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CAPTURE_TYPE_SEQUENCE))
#define CAPTURE_SEQUENCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CAPTURE_TYPE_SEQUENCE, CaptureSequenceClass))

typedef struct _CaptureSequence CaptureSequence;
typedef struct _CaptureSequenceClass CaptureSequenceClass;
typedef struct _CaptureSequencePrivate CaptureSequencePrivate;
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block3Data Block3Data;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _capture_sequence_unref0(var) ((var == NULL) ? NULL : (var = (capture_sequence_unref (var), NULL)))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block4Data Block4Data;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
typedef struct _CaptureParamSpecSequence CaptureParamSpecSequence;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _CaptureSequence {
	GTypeInstance parent_instance;
	volatile int ref_count;
	CaptureSequencePrivate * priv;
	GList* pixbufs;
};

struct _CaptureSequenceClass {
	GTypeClass parent_class;
	void (*finalize) (CaptureSequence *self);
};

struct _CaptureSequencePrivate {
	guint _frame;
	guint _framerate;
};

struct _Block3Data {
	int _ref_count_;
	CaptureSequence* self;
	gchar* dirname;
	GtkWindow* win;
	GtkProgressBar* progress_bar;
	gchar* filename;
};

struct _Block4Data {
	int _ref_count_;
	Block3Data * _data3_;
	GMainLoop* loop;
	gchar* tmp_filename;
	GPid child_pid;
};

struct _CaptureParamSpecSequence {
	GParamSpec parent_instance;
};


static gpointer capture_sequence_parent_class = NULL;

gpointer capture_sequence_ref (gpointer instance);
void capture_sequence_unref (gpointer instance);
GParamSpec* capture_param_spec_sequence (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void capture_value_set_sequence (GValue* value, gpointer v_object);
void capture_value_take_sequence (GValue* value, gpointer v_object);
gpointer capture_value_get_sequence (const GValue* value);
GType capture_sequence_get_type (void) G_GNUC_CONST;
#define CAPTURE_SEQUENCE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CAPTURE_TYPE_SEQUENCE, CaptureSequencePrivate))
enum  {
	CAPTURE_SEQUENCE_DUMMY_PROPERTY
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
CaptureSequence* capture_sequence_new (void);
CaptureSequence* capture_sequence_construct (GType object_type);
void capture_sequence_set_frame (CaptureSequence* self, guint value);
void capture_sequence_add (CaptureSequence* self, GdkPixbuf* pixbuf);
guint capture_sequence_length (CaptureSequence* self);
GdkPixbuf* capture_sequence_first (CaptureSequence* self);
GdkPixbuf* capture_sequence_next (CaptureSequence* self);
guint capture_sequence_get_frame (CaptureSequence* self);
GdkPixbuf* capture_sequence_previous (CaptureSequence* self);
gboolean capture_sequence_save_to_animated_gif (CaptureSequence* self, const gchar* filename);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
guint capture_sequence_get_framerate (CaptureSequence* self);
static void ___lambda4_ (Block4Data* _data4_);
static void ____lambda4__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void ___lambda5_ (Block4Data* _data4_, GPid pid, gint status);
static void __lambda6_ (Block4Data* _data4_, GPid pid, gint status);
static void ___lambda6__gchild_watch_func (GPid pid, gint status, gpointer self);
static void ____lambda5__gchild_watch_func (GPid pid, gint status, gpointer self);
static gboolean ___lambda7_ (Block4Data* _data4_);
static gboolean ____lambda7__gsource_func (gpointer self);
void capture_sequence_set_framerate (CaptureSequence* self, guint value);
static void capture_sequence_finalize (CaptureSequence* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


CaptureSequence* capture_sequence_construct (GType object_type) {
	CaptureSequence* self = NULL;
	self = (CaptureSequence*) g_type_create_instance (object_type);
	__g_list_free__g_object_unref0_0 (self->pixbufs);
	self->pixbufs = NULL;
	capture_sequence_set_frame (self, (guint) 0);
	return self;
}


CaptureSequence* capture_sequence_new (void) {
	return capture_sequence_construct (CAPTURE_TYPE_SEQUENCE);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void capture_sequence_add (CaptureSequence* self, GdkPixbuf* pixbuf) {
	GdkPixbuf* _tmp0_ = NULL;
	GdkPixbuf* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (pixbuf != NULL);
	_tmp0_ = pixbuf;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	self->pixbufs = g_list_append (self->pixbufs, _tmp1_);
}


guint capture_sequence_length (CaptureSequence* self) {
	guint result = 0U;
	GList* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->pixbufs;
	_tmp1_ = g_list_length (_tmp0_);
	result = _tmp1_;
	return result;
}


GdkPixbuf* capture_sequence_first (CaptureSequence* self) {
	GdkPixbuf* result = NULL;
	GList* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	GList* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	GdkPixbuf* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->pixbufs;
	_tmp1_ = g_list_length (_tmp0_);
	_vala_assert (_tmp1_ > ((guint) 0), "pixbufs.length() > 0");
	_tmp2_ = self->pixbufs;
	_tmp3_ = g_list_nth_data (_tmp2_, (guint) 0);
	_tmp4_ = _g_object_ref0 ((GdkPixbuf*) _tmp3_);
	result = _tmp4_;
	return result;
}


GdkPixbuf* capture_sequence_next (CaptureSequence* self) {
	GdkPixbuf* result = NULL;
	GList* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	guint _tmp2_ = 0U;
	guint _tmp3_ = 0U;
	GList* _tmp4_ = NULL;
	guint _tmp5_ = 0U;
	gconstpointer _tmp6_ = NULL;
	GdkPixbuf* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->pixbufs;
	_tmp1_ = g_list_length (_tmp0_);
	_vala_assert (_tmp1_ > ((guint) 0), "pixbufs.length() > 0");
	_tmp2_ = self->priv->_frame;
	capture_sequence_set_frame (self, _tmp2_ + 1);
	_tmp3_ = capture_sequence_length (self);
	if ((_tmp2_ + 1) >= _tmp3_) {
		capture_sequence_set_frame (self, (guint) 0);
	}
	_tmp4_ = self->pixbufs;
	_tmp5_ = self->priv->_frame;
	_tmp6_ = g_list_nth_data (_tmp4_, _tmp5_);
	_tmp7_ = _g_object_ref0 ((GdkPixbuf*) _tmp6_);
	result = _tmp7_;
	return result;
}


GdkPixbuf* capture_sequence_previous (CaptureSequence* self) {
	GdkPixbuf* result = NULL;
	GList* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	guint _tmp2_ = 0U;
	GList* _tmp6_ = NULL;
	guint _tmp7_ = 0U;
	gconstpointer _tmp8_ = NULL;
	GdkPixbuf* _tmp9_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->pixbufs;
	_tmp1_ = g_list_length (_tmp0_);
	_vala_assert (_tmp1_ > ((guint) 0), "pixbufs.length() > 0");
	_tmp2_ = self->priv->_frame;
	if (_tmp2_ == ((guint) 0)) {
		GList* _tmp3_ = NULL;
		guint _tmp4_ = 0U;
		_tmp3_ = self->pixbufs;
		_tmp4_ = g_list_length (_tmp3_);
		capture_sequence_set_frame (self, _tmp4_ - 1);
	} else {
		guint _tmp5_ = 0U;
		_tmp5_ = self->priv->_frame;
		capture_sequence_set_frame (self, _tmp5_ - 1);
	}
	_tmp6_ = self->pixbufs;
	_tmp7_ = self->priv->_frame;
	_tmp8_ = g_list_nth_data (_tmp6_, _tmp7_);
	_tmp9_ = _g_object_ref0 ((GdkPixbuf*) _tmp8_);
	result = _tmp9_;
	return result;
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		CaptureSequence* self;
		self = _data3_->self;
		_g_object_unref0 (_data3_->progress_bar);
		_g_object_unref0 (_data3_->win);
		_g_free0 (_data3_->dirname);
		_g_free0 (_data3_->filename);
		_capture_sequence_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (void * _userdata_) {
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		CaptureSequence* self;
		self = _data4_->_data3_->self;
		_g_free0 (_data4_->tmp_filename);
		_g_main_loop_unref0 (_data4_->loop);
		block3_data_unref (_data4_->_data3_);
		_data4_->_data3_ = NULL;
		g_slice_free (Block4Data, _data4_);
	}
}


static void ___lambda4_ (Block4Data* _data4_) {
	Block3Data* _data3_;
	CaptureSequence* self;
	GPid _tmp0_ = 0;
	_data3_ = _data4_->_data3_;
	self = _data3_->self;
	_tmp0_ = _data4_->child_pid;
	kill ((pid_t) _tmp0_, (gint) SIGTERM);
}


static void ____lambda4__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	___lambda4_ (self);
}


static void __lambda6_ (Block4Data* _data4_, GPid pid, gint status) {
	Block3Data* _data3_;
	CaptureSequence* self;
	gint _tmp0_ = 0;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GPid _tmp3_ = 0;
	GMainLoop* _tmp4_ = NULL;
	GtkWindow* _tmp5_ = NULL;
	_data3_ = _data4_->_data3_;
	self = _data3_->self;
	_tmp0_ = status;
	_tmp1_ = g_strdup_printf ("Child exited with status: %u", (guint) _tmp0_);
	_tmp2_ = _tmp1_;
	plank_logger_notification (_tmp2_, "");
	_g_free0 (_tmp2_);
	_tmp3_ = pid;
	g_spawn_close_pid (_tmp3_);
	_tmp4_ = _data4_->loop;
	g_main_loop_quit (_tmp4_);
	_tmp5_ = _data3_->win;
	gtk_widget_destroy ((GtkWidget*) _tmp5_);
}


static void ___lambda6__gchild_watch_func (GPid pid, gint status, gpointer self) {
	__lambda6_ (self, pid, status);
}


static void ___lambda5_ (Block4Data* _data4_, GPid pid, gint status) {
	Block3Data* _data3_;
	CaptureSequence* self;
	gint _tmp0_ = 0;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GPid _tmp3_ = 0;
	gchar* args2[6] = {0};
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_[6] = {0};
	const gchar* _tmp12_ = NULL;
	GPid _tmp13_ = 0;
	GPid _tmp14_ = 0;
	GError * _inner_error_ = NULL;
	_data3_ = _data4_->_data3_;
	self = _data3_->self;
	_tmp0_ = status;
	_tmp1_ = g_strdup_printf ("Child exited with status: %u", (guint) _tmp0_);
	_tmp2_ = _tmp1_;
	plank_logger_notification (_tmp2_, "");
	_g_free0 (_tmp2_);
	_tmp3_ = pid;
	g_spawn_close_pid (_tmp3_);
	_tmp4_ = g_strdup ("/usr/bin/convert");
	_tmp5_ = g_strdup ("-layers");
	_tmp6_ = g_strdup ("Optimize");
	_tmp7_ = _data4_->tmp_filename;
	_tmp8_ = g_strdup (_tmp7_);
	_tmp9_ = _data3_->filename;
	_tmp10_ = g_strdup (_tmp9_);
	_tmp11_[0] = _tmp4_;
	_tmp11_[1] = _tmp5_;
	_tmp11_[2] = _tmp6_;
	_tmp11_[3] = _tmp8_;
	_tmp11_[4] = _tmp10_;
	_tmp11_[5] = NULL;
	memcpy (args2, _tmp11_, 6 * sizeof (gchar*));
	_tmp12_ = _data3_->dirname;
	g_spawn_async (_tmp12_, args2, NULL, G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &_tmp13_, &_inner_error_);
	_data4_->child_pid = _tmp13_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_vala_array_destroy (args2, 6, (GDestroyNotify) g_free);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp14_ = _data4_->child_pid;
	g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp14_, ___lambda6__gchild_watch_func, block4_data_ref (_data4_), block4_data_unref);
	_vala_array_destroy (args2, 6, (GDestroyNotify) g_free);
}


static void ____lambda5__gchild_watch_func (GPid pid, gint status, gpointer self) {
	___lambda5_ (self, pid, status);
}


static gboolean ___lambda7_ (Block4Data* _data4_) {
	Block3Data* _data3_;
	CaptureSequence* self;
	gboolean result = FALSE;
	GtkProgressBar* _tmp0_ = NULL;
	_data3_ = _data4_->_data3_;
	self = _data3_->self;
	_tmp0_ = _data3_->progress_bar;
	gtk_progress_bar_pulse (_tmp0_);
	result = TRUE;
	return result;
}


static gboolean ____lambda7__gsource_func (gpointer self) {
	gboolean result;
	result = ___lambda7_ (self);
	return result;
}


gboolean capture_sequence_save_to_animated_gif (CaptureSequence* self, const gchar* filename) {
	gboolean result = FALSE;
	Block3Data* _data3_;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GDateTime* _tmp3_ = NULL;
	GDateTime* _tmp4_ = NULL;
	gint64 _tmp5_ = 0LL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	GtkWindow* _tmp19_ = NULL;
	GtkBox* vbox = NULL;
	GtkBox* _tmp20_ = NULL;
	GtkProgressBar* _tmp21_ = NULL;
	GtkBox* _tmp22_ = NULL;
	GtkProgressBar* _tmp23_ = NULL;
	GtkButton* cancel_button = NULL;
	GtkButton* _tmp24_ = NULL;
	GtkButton* _tmp25_ = NULL;
	GtkBox* _tmp26_ = NULL;
	GtkButton* _tmp27_ = NULL;
	GtkWindow* _tmp28_ = NULL;
	GtkBox* _tmp29_ = NULL;
	GtkWindow* _tmp30_ = NULL;
	GtkWindow* _tmp31_ = NULL;
	guint n = 0U;
	guint m = 0U;
	GList* _tmp32_ = NULL;
	guint _tmp33_ = 0U;
	GList* _tmp34_ = NULL;
	guint _tmp52_ = 0U;
	guint _tmp53_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (filename != NULL, FALSE);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->self = capture_sequence_ref (self);
	_tmp0_ = filename;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (_data3_->filename);
	_data3_->filename = _tmp1_;
	_tmp2_ = g_get_tmp_dir ();
	_tmp3_ = g_date_time_new_now_local ();
	_tmp4_ = _tmp3_;
	_tmp5_ = g_date_time_to_unix (_tmp4_);
	_tmp6_ = g_strdup_printf ("%" G_GINT64_FORMAT, _tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_build_path (G_DIR_SEPARATOR_S, _tmp2_, "capture", _tmp7_, NULL);
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	_g_date_time_unref0 (_tmp4_);
	_data3_->dirname = _tmp9_;
	_tmp10_ = _data3_->dirname;
	_tmp11_ = g_strdup_printf ("Creating temp dir: %s", _tmp10_);
	_tmp12_ = _tmp11_;
	plank_logger_notification (_tmp12_, "");
	_g_free0 (_tmp12_);
	{
		GFile* dir = NULL;
		const gchar* _tmp13_ = NULL;
		GFile* _tmp14_ = NULL;
		GFile* _tmp15_ = NULL;
		_tmp13_ = _data3_->dirname;
		_tmp14_ = g_file_new_for_path (_tmp13_);
		dir = _tmp14_;
		_tmp15_ = dir;
		g_file_make_directory_with_parents (_tmp15_, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (dir);
			goto __catch1_g_error;
		}
		_g_object_unref0 (dir);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp16_ = NULL;
		GError* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp16_ = _data3_->dirname;
		_tmp17_ = e;
		_tmp18_ = _tmp17_->message;
		g_warning ("Sequence.vala:83: Could not create directory: %s: %s", _tmp16_, _tmp18_);
		result = FALSE;
		_g_error_free0 (e);
		block3_data_unref (_data3_);
		_data3_ = NULL;
		return result;
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		block3_data_unref (_data3_);
		_data3_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp19_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL);
	g_object_ref_sink (_tmp19_);
	_data3_->win = _tmp19_;
	_tmp20_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp20_);
	vbox = _tmp20_;
	_tmp21_ = (GtkProgressBar*) gtk_progress_bar_new ();
	g_object_ref_sink (_tmp21_);
	_data3_->progress_bar = _tmp21_;
	_tmp22_ = vbox;
	_tmp23_ = _data3_->progress_bar;
	gtk_box_pack_start (_tmp22_, (GtkWidget*) _tmp23_, TRUE, FALSE, (guint) 0);
	_tmp24_ = (GtkButton*) gtk_button_new_with_label ("Cancel");
	g_object_ref_sink (_tmp24_);
	cancel_button = _tmp24_;
	_tmp25_ = cancel_button;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp25_, FALSE);
	_tmp26_ = vbox;
	_tmp27_ = cancel_button;
	gtk_box_pack_start (_tmp26_, (GtkWidget*) _tmp27_, TRUE, TRUE, (guint) 0);
	_tmp28_ = _data3_->win;
	_tmp29_ = vbox;
	gtk_container_add ((GtkContainer*) _tmp28_, (GtkWidget*) _tmp29_);
	_tmp30_ = _data3_->win;
	gtk_widget_show_all ((GtkWidget*) _tmp30_);
	_tmp31_ = _data3_->win;
	gtk_window_present (_tmp31_);
	n = (guint) 1;
	_tmp32_ = self->pixbufs;
	_tmp33_ = g_list_length (_tmp32_);
	m = _tmp33_ + 1;
	_tmp34_ = self->pixbufs;
	{
		GList* pixbuf_collection = NULL;
		GList* pixbuf_it = NULL;
		pixbuf_collection = _tmp34_;
		for (pixbuf_it = pixbuf_collection; pixbuf_it != NULL; pixbuf_it = pixbuf_it->next) {
			GdkPixbuf* _tmp35_ = NULL;
			GdkPixbuf* pixbuf = NULL;
			_tmp35_ = _g_object_ref0 ((GdkPixbuf*) pixbuf_it->data);
			pixbuf = _tmp35_;
			{
				{
					gchar* frame_filename = NULL;
					const gchar* _tmp36_ = NULL;
					guint _tmp37_ = 0U;
					gchar* _tmp38_ = NULL;
					gchar* _tmp39_ = NULL;
					gchar* _tmp40_ = NULL;
					gchar* _tmp41_ = NULL;
					const gchar* _tmp42_ = NULL;
					gchar* _tmp43_ = NULL;
					gchar* _tmp44_ = NULL;
					GdkPixbuf* _tmp45_ = NULL;
					const gchar* _tmp46_ = NULL;
					GtkProgressBar* _tmp47_ = NULL;
					guint _tmp48_ = 0U;
					guint _tmp49_ = 0U;
					_tmp36_ = _data3_->dirname;
					_tmp37_ = n;
					n = _tmp37_ + 1;
					_tmp38_ = g_strdup_printf ("frame-%04u", _tmp37_);
					_tmp39_ = _tmp38_;
					_tmp40_ = g_build_filename (_tmp36_, _tmp39_, NULL);
					_tmp41_ = _tmp40_;
					_g_free0 (_tmp39_);
					frame_filename = _tmp41_;
					_tmp42_ = frame_filename;
					_tmp43_ = g_strdup_printf ("Saving frame %s", _tmp42_);
					_tmp44_ = _tmp43_;
					plank_logger_notification (_tmp44_, "");
					_g_free0 (_tmp44_);
					_tmp45_ = pixbuf;
					_tmp46_ = frame_filename;
					gdk_pixbuf_save (_tmp45_, _tmp46_, "png", &_inner_error_, NULL);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_free0 (frame_filename);
						goto __catch2_g_error;
					}
					_tmp47_ = _data3_->progress_bar;
					_tmp48_ = n;
					_tmp49_ = m;
					gtk_progress_bar_set_fraction (_tmp47_, (gdouble) (_tmp48_ / _tmp49_));
					_g_free0 (frame_filename);
				}
				goto __finally2;
				__catch2_g_error:
				{
					GError* e = NULL;
					GError* _tmp50_ = NULL;
					const gchar* _tmp51_ = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					_tmp50_ = e;
					_tmp51_ = _tmp50_->message;
					g_warning ("Sequence.vala:113: Failed to save pixbuf: %s", _tmp51_);
					_g_error_free0 (e);
					_g_object_unref0 (pixbuf);
					break;
				}
				__finally2:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (pixbuf);
					_g_object_unref0 (cancel_button);
					_g_object_unref0 (vbox);
					block3_data_unref (_data3_);
					_data3_ = NULL;
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
				_g_object_unref0 (pixbuf);
			}
		}
	}
	_tmp52_ = n;
	_tmp53_ = m;
	if (_tmp52_ != _tmp53_) {
		guint _tmp54_ = 0U;
		guint _tmp55_ = 0U;
		_tmp54_ = n;
		_tmp55_ = m;
		g_warning ("Sequence.vala:119: Could not save all frames (%u of %u), aborting conv" \
"ersion to gif", _tmp54_, _tmp55_);
		result = FALSE;
		_g_object_unref0 (cancel_button);
		_g_object_unref0 (vbox);
		block3_data_unref (_data3_);
		_data3_ = NULL;
		return result;
	}
	plank_logger_notification ("Now calling convert, this can take some time...", "");
	{
		Block4Data* _data4_;
		GMainLoop* _tmp56_ = NULL;
		const gchar* _tmp57_ = NULL;
		gchar* _tmp58_ = NULL;
		gchar* delay = NULL;
		guint _tmp59_ = 0U;
		gchar* _tmp60_ = NULL;
		gchar* args[8] = {0};
		gchar* _tmp61_ = NULL;
		gchar* _tmp62_ = NULL;
		const gchar* _tmp63_ = NULL;
		gchar* _tmp64_ = NULL;
		gchar* _tmp65_ = NULL;
		gchar* _tmp66_ = NULL;
		gchar* _tmp67_ = NULL;
		const gchar* _tmp68_ = NULL;
		gchar* _tmp69_ = NULL;
		gchar* _tmp70_[8] = {0};
		const gchar* _tmp71_ = NULL;
		GPid _tmp72_ = 0;
		GPid _tmp73_ = 0;
		gchar* _tmp74_ = NULL;
		gchar* _tmp75_ = NULL;
		GtkButton* _tmp76_ = NULL;
		GtkButton* _tmp77_ = NULL;
		GPid _tmp78_ = 0;
		GMainLoop* _tmp79_ = NULL;
		_data4_ = g_slice_new0 (Block4Data);
		_data4_->_ref_count_ = 1;
		_data4_->_data3_ = block3_data_ref (_data3_);
		_tmp56_ = g_main_loop_new (NULL, FALSE);
		_data4_->loop = _tmp56_;
		_tmp57_ = _data3_->dirname;
		_tmp58_ = g_build_filename (_tmp57_, "tmp.gif", NULL);
		_data4_->tmp_filename = _tmp58_;
		_tmp59_ = self->priv->_framerate;
		_tmp60_ = g_strdup_printf ("%u", 100 / _tmp59_);
		delay = _tmp60_;
		_tmp61_ = g_strdup ("/usr/bin/convert");
		_tmp62_ = g_strdup ("-delay");
		_tmp63_ = delay;
		_tmp64_ = g_strdup (_tmp63_);
		_tmp65_ = g_strdup ("-loop");
		_tmp66_ = g_strdup ("0");
		_tmp67_ = g_strdup ("*");
		_tmp68_ = _data4_->tmp_filename;
		_tmp69_ = g_strdup (_tmp68_);
		_tmp70_[0] = _tmp61_;
		_tmp70_[1] = _tmp62_;
		_tmp70_[2] = _tmp64_;
		_tmp70_[3] = _tmp65_;
		_tmp70_[4] = _tmp66_;
		_tmp70_[5] = _tmp67_;
		_tmp70_[6] = _tmp69_;
		_tmp70_[7] = NULL;
		memcpy (args, _tmp70_, 8 * sizeof (gchar*));
		_tmp71_ = _data3_->dirname;
		g_spawn_async (_tmp71_, args, NULL, G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &_tmp72_, &_inner_error_);
		_data4_->child_pid = _tmp72_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_vala_array_destroy (args, 8, (GDestroyNotify) g_free);
			_g_free0 (delay);
			block4_data_unref (_data4_);
			_data4_ = NULL;
			if (_inner_error_->domain == G_SPAWN_ERROR) {
				goto __catch3_g_spawn_error;
			}
			_vala_array_destroy (args, 8, (GDestroyNotify) g_free);
			_g_free0 (delay);
			block4_data_unref (_data4_);
			_data4_ = NULL;
			_g_object_unref0 (cancel_button);
			_g_object_unref0 (vbox);
			block3_data_unref (_data3_);
			_data3_ = NULL;
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		_tmp73_ = _data4_->child_pid;
		_tmp74_ = g_strdup_printf ("Spawned process with PID: %u", (guint) _tmp73_);
		_tmp75_ = _tmp74_;
		plank_logger_notification (_tmp75_, "");
		_g_free0 (_tmp75_);
		_tmp76_ = cancel_button;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp76_, TRUE);
		_tmp77_ = cancel_button;
		g_signal_connect_data (_tmp77_, "clicked", (GCallback) ____lambda4__gtk_button_clicked, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
		_tmp78_ = _data4_->child_pid;
		g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp78_, ____lambda5__gchild_watch_func, block4_data_ref (_data4_), block4_data_unref);
		g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 250, ____lambda7__gsource_func, block4_data_ref (_data4_), block4_data_unref);
		_tmp79_ = _data4_->loop;
		g_main_loop_run (_tmp79_);
		_vala_array_destroy (args, 8, (GDestroyNotify) g_free);
		_g_free0 (delay);
		block4_data_unref (_data4_);
		_data4_ = NULL;
	}
	goto __finally3;
	__catch3_g_spawn_error:
	{
		GError* e = NULL;
		GError* _tmp80_ = NULL;
		const gchar* _tmp81_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp80_ = e;
		_tmp81_ = _tmp80_->message;
		g_warning ("Sequence.vala:177: Error: %s", _tmp81_);
		result = FALSE;
		_g_error_free0 (e);
		_g_object_unref0 (cancel_button);
		_g_object_unref0 (vbox);
		block3_data_unref (_data3_);
		_data3_ = NULL;
		return result;
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (cancel_button);
		_g_object_unref0 (vbox);
		block3_data_unref (_data3_);
		_data3_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	_g_object_unref0 (cancel_button);
	_g_object_unref0 (vbox);
	block3_data_unref (_data3_);
	_data3_ = NULL;
	return result;
}


guint capture_sequence_get_frame (CaptureSequence* self) {
	guint result;
	guint _tmp0_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->_frame;
	result = _tmp0_;
	return result;
}


void capture_sequence_set_frame (CaptureSequence* self, guint value) {
	guint _tmp0_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_frame = _tmp0_;
}


guint capture_sequence_get_framerate (CaptureSequence* self) {
	guint result;
	guint _tmp0_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->_framerate;
	result = _tmp0_;
	return result;
}


void capture_sequence_set_framerate (CaptureSequence* self, guint value) {
	guint _tmp0_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_framerate = _tmp0_;
}


static void capture_value_sequence_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void capture_value_sequence_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		capture_sequence_unref (value->data[0].v_pointer);
	}
}


static void capture_value_sequence_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = capture_sequence_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer capture_value_sequence_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* capture_value_sequence_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		CaptureSequence* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = capture_sequence_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* capture_value_sequence_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	CaptureSequence** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = capture_sequence_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* capture_param_spec_sequence (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	CaptureParamSpecSequence* spec;
	g_return_val_if_fail (g_type_is_a (object_type, CAPTURE_TYPE_SEQUENCE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer capture_value_get_sequence (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CAPTURE_TYPE_SEQUENCE), NULL);
	return value->data[0].v_pointer;
}


void capture_value_set_sequence (GValue* value, gpointer v_object) {
	CaptureSequence* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CAPTURE_TYPE_SEQUENCE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, CAPTURE_TYPE_SEQUENCE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		capture_sequence_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		capture_sequence_unref (old);
	}
}


void capture_value_take_sequence (GValue* value, gpointer v_object) {
	CaptureSequence* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CAPTURE_TYPE_SEQUENCE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, CAPTURE_TYPE_SEQUENCE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		capture_sequence_unref (old);
	}
}


static void capture_sequence_class_init (CaptureSequenceClass * klass) {
	capture_sequence_parent_class = g_type_class_peek_parent (klass);
	((CaptureSequenceClass *) klass)->finalize = capture_sequence_finalize;
	g_type_class_add_private (klass, sizeof (CaptureSequencePrivate));
}


static void capture_sequence_instance_init (CaptureSequence * self) {
	self->priv = CAPTURE_SEQUENCE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void capture_sequence_finalize (CaptureSequence* obj) {
	CaptureSequence * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CAPTURE_TYPE_SEQUENCE, CaptureSequence);
	g_signal_handlers_destroy (self);
	__g_list_free__g_object_unref0_0 (self->pixbufs);
}


GType capture_sequence_get_type (void) {
	static volatile gsize capture_sequence_type_id__volatile = 0;
	if (g_once_init_enter (&capture_sequence_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { capture_value_sequence_init, capture_value_sequence_free_value, capture_value_sequence_copy_value, capture_value_sequence_peek_pointer, "p", capture_value_sequence_collect_value, "p", capture_value_sequence_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (CaptureSequenceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) capture_sequence_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CaptureSequence), 0, (GInstanceInitFunc) capture_sequence_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType capture_sequence_type_id;
		capture_sequence_type_id = g_type_register_fundamental (g_type_fundamental_next (), "CaptureSequence", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&capture_sequence_type_id__volatile, capture_sequence_type_id);
	}
	return capture_sequence_type_id__volatile;
}


gpointer capture_sequence_ref (gpointer instance) {
	CaptureSequence* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void capture_sequence_unref (gpointer instance) {
	CaptureSequence* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		CAPTURE_SEQUENCE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



