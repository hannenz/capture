/* ScreenGrabber.c generated by valac 0.34.4, the Vala compiler
 * generated from ScreenGrabber.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gdk/gdk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <plank.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gobject/gvaluecollector.h>


#define CAPTURE_TYPE_SCREEN_GRAB_MODE (capture_screen_grab_mode_get_type ())

#define CAPTURE_TYPE_SCREEN_GRABBER (capture_screen_grabber_get_type ())
#define CAPTURE_SCREEN_GRABBER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CAPTURE_TYPE_SCREEN_GRABBER, CaptureScreenGrabber))
#define CAPTURE_SCREEN_GRABBER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CAPTURE_TYPE_SCREEN_GRABBER, CaptureScreenGrabberClass))
#define CAPTURE_IS_SCREEN_GRABBER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CAPTURE_TYPE_SCREEN_GRABBER))
#define CAPTURE_IS_SCREEN_GRABBER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CAPTURE_TYPE_SCREEN_GRABBER))
#define CAPTURE_SCREEN_GRABBER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CAPTURE_TYPE_SCREEN_GRABBER, CaptureScreenGrabberClass))

typedef struct _CaptureScreenGrabber CaptureScreenGrabber;
typedef struct _CaptureScreenGrabberClass CaptureScreenGrabberClass;
typedef struct _CaptureScreenGrabberPrivate CaptureScreenGrabberPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _CaptureParamSpecScreenGrabber CaptureParamSpecScreenGrabber;

typedef enum  {
	CAPTURE_SCREEN_GRAB_MODE_DESKTOP,
	CAPTURE_SCREEN_GRAB_MODE_WINDOW,
	CAPTURE_SCREEN_GRAB_MODE_REGION
} CaptureScreenGrabMode;

struct _CaptureScreenGrabber {
	GTypeInstance parent_instance;
	volatile int ref_count;
	CaptureScreenGrabberPrivate * priv;
};

struct _CaptureScreenGrabberClass {
	GTypeClass parent_class;
	void (*finalize) (CaptureScreenGrabber *self);
};

struct _CaptureScreenGrabberPrivate {
	GdkDisplay* default_display;
	GdkScreen* default_screen;
	GdkPixbuf* cursor_pixbuf;
	gint cursor_x;
	gint cursor_y;
	gboolean _include_cursor;
	GdkPixbuf* _pixbuf;
	CaptureScreenGrabMode _mode;
};

struct _CaptureParamSpecScreenGrabber {
	GParamSpec parent_instance;
};


static gpointer capture_screen_grabber_parent_class = NULL;

GType capture_screen_grab_mode_get_type (void) G_GNUC_CONST;
gpointer capture_screen_grabber_ref (gpointer instance);
void capture_screen_grabber_unref (gpointer instance);
GParamSpec* capture_param_spec_screen_grabber (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void capture_value_set_screen_grabber (GValue* value, gpointer v_object);
void capture_value_take_screen_grabber (GValue* value, gpointer v_object);
gpointer capture_value_get_screen_grabber (const GValue* value);
GType capture_screen_grabber_get_type (void) G_GNUC_CONST;
#define CAPTURE_SCREEN_GRABBER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CAPTURE_TYPE_SCREEN_GRABBER, CaptureScreenGrabberPrivate))
enum  {
	CAPTURE_SCREEN_GRABBER_DUMMY_PROPERTY
};
CaptureScreenGrabber* capture_screen_grabber_new (CaptureScreenGrabMode mode, gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_construct (GType object_type, CaptureScreenGrabMode mode, gboolean include_cursor);
void capture_screen_grabber_set_mode (CaptureScreenGrabber* self, CaptureScreenGrabMode value);
void capture_screen_grabber_set_include_cursor (CaptureScreenGrabber* self, gboolean value);
GdkPixbuf* capture_screen_grabber_grab (CaptureScreenGrabber* self, GdkRectangle* selection);
gboolean capture_screen_grabber_get_include_cursor (CaptureScreenGrabber* self);
void capture_screen_grabber_set_pixbuf (CaptureScreenGrabber* self, GdkPixbuf* value);
CaptureScreenGrabMode capture_screen_grabber_get_mode (CaptureScreenGrabber* self);
GdkPixbuf* capture_screen_grabber_get_pixbuf (CaptureScreenGrabber* self);
CaptureScreenGrabber* capture_screen_grabber_new_from_region (gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_construct_from_region (GType object_type, gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_new_from_window (gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_construct_from_window (GType object_type, gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_new_from_desktop (gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_construct_from_desktop (GType object_type, gboolean include_cursor);
static void capture_screen_grabber_finalize (CaptureScreenGrabber* obj);


GType capture_screen_grab_mode_get_type (void) {
	static volatile gsize capture_screen_grab_mode_type_id__volatile = 0;
	if (g_once_init_enter (&capture_screen_grab_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{CAPTURE_SCREEN_GRAB_MODE_DESKTOP, "CAPTURE_SCREEN_GRAB_MODE_DESKTOP", "desktop"}, {CAPTURE_SCREEN_GRAB_MODE_WINDOW, "CAPTURE_SCREEN_GRAB_MODE_WINDOW", "window"}, {CAPTURE_SCREEN_GRAB_MODE_REGION, "CAPTURE_SCREEN_GRAB_MODE_REGION", "region"}, {0, NULL, NULL}};
		GType capture_screen_grab_mode_type_id;
		capture_screen_grab_mode_type_id = g_enum_register_static ("CaptureScreenGrabMode", values);
		g_once_init_leave (&capture_screen_grab_mode_type_id__volatile, capture_screen_grab_mode_type_id);
	}
	return capture_screen_grab_mode_type_id__volatile;
}


static gchar* bool_to_string (gboolean self) {
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_ = NULL;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}


CaptureScreenGrabber* capture_screen_grabber_construct (GType object_type, CaptureScreenGrabMode mode, gboolean include_cursor) {
	CaptureScreenGrabber* self = NULL;
	CaptureScreenGrabMode _tmp0_ = 0;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	self = (CaptureScreenGrabber*) g_type_create_instance (object_type);
	_tmp0_ = mode;
	capture_screen_grabber_set_mode (self, _tmp0_);
	_tmp1_ = include_cursor;
	capture_screen_grabber_set_include_cursor (self, _tmp1_);
	_tmp2_ = include_cursor;
	_tmp3_ = bool_to_string (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strdup_printf ("include_cursor=%s", _tmp4_);
	_tmp6_ = _tmp5_;
	plank_logger_notification (_tmp6_, "");
	_g_free0 (_tmp6_);
	_g_free0 (_tmp4_);
	return self;
}


CaptureScreenGrabber* capture_screen_grabber_new (CaptureScreenGrabMode mode, gboolean include_cursor) {
	return capture_screen_grabber_construct (CAPTURE_TYPE_SCREEN_GRABBER, mode, include_cursor);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GdkPixbuf* capture_screen_grabber_grab (CaptureScreenGrabber* self, GdkRectangle* selection) {
	GdkPixbuf* result = NULL;
	GdkDisplay* _tmp0_ = NULL;
	GdkDisplay* _tmp1_ = NULL;
	GdkDisplay* _tmp2_ = NULL;
	GdkScreen* _tmp3_ = NULL;
	GdkScreen* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	CaptureScreenGrabMode _tmp18_ = 0;
	GdkPixbuf* _tmp114_ = NULL;
	GdkPixbuf* _tmp115_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gdk_display_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->default_display);
	self->priv->default_display = _tmp1_;
	_tmp2_ = self->priv->default_display;
	_tmp3_ = gdk_display_get_default_screen (_tmp2_);
	_tmp4_ = _g_object_ref0 (_tmp3_);
	_g_object_unref0 (self->priv->default_screen);
	self->priv->default_screen = _tmp4_;
	_tmp5_ = self->priv->_include_cursor;
	if (_tmp5_) {
		GdkCursor* crsr = NULL;
		GdkDisplay* _tmp6_ = NULL;
		GdkCursor* _tmp7_ = NULL;
		GdkCursor* _tmp8_ = NULL;
		GdkCursor* _tmp9_ = NULL;
		GdkPixbuf* _tmp10_ = NULL;
		GdkPixbuf* _tmp11_ = NULL;
		GdkWindow* _tmp12_ = NULL;
		GdkDisplay* _tmp13_ = NULL;
		GdkDeviceManager* _tmp14_ = NULL;
		GdkDevice* _tmp15_ = NULL;
		gint _tmp16_ = 0;
		gint _tmp17_ = 0;
		_tmp6_ = self->priv->default_display;
		_tmp7_ = gdk_cursor_new_for_display (_tmp6_, GDK_LEFT_PTR);
		crsr = _tmp7_;
		_tmp8_ = crsr;
		if (_tmp8_ == NULL) {
			plank_logger_notification ("The cursor is NULL", "");
		}
		_tmp9_ = crsr;
		_tmp10_ = gdk_cursor_get_image (_tmp9_);
		_g_object_unref0 (self->priv->cursor_pixbuf);
		self->priv->cursor_pixbuf = _tmp10_;
		_tmp11_ = self->priv->cursor_pixbuf;
		if (_tmp11_ == NULL) {
			plank_logger_notification ("*** OH NOES! cursor_pixbuf is NULL! ***", "");
		}
		_tmp12_ = gdk_get_default_root_window ();
		_tmp13_ = gdk_display_get_default ();
		_tmp14_ = gdk_display_get_device_manager (_tmp13_);
		_tmp15_ = gdk_device_manager_get_client_pointer (_tmp14_);
		gdk_window_get_device_position (_tmp12_, _tmp15_, &_tmp16_, &_tmp17_, NULL);
		self->priv->cursor_x = _tmp16_;
		self->priv->cursor_y = _tmp17_;
		_g_object_unref0 (crsr);
	}
	capture_screen_grabber_set_pixbuf (self, NULL);
	_tmp18_ = self->priv->_mode;
	switch (_tmp18_) {
		case CAPTURE_SCREEN_GRAB_MODE_DESKTOP:
		{
			GdkWindow* window = NULL;
			GdkWindow* _tmp19_ = NULL;
			GdkWindow* _tmp20_ = NULL;
			GdkWindow* _tmp21_ = NULL;
			GdkWindow* _tmp22_ = NULL;
			gint _tmp23_ = 0;
			GdkWindow* _tmp24_ = NULL;
			gint _tmp25_ = 0;
			GdkPixbuf* _tmp26_ = NULL;
			GdkPixbuf* _tmp27_ = NULL;
			gboolean _tmp28_ = FALSE;
			GdkPixbuf* _tmp45_ = NULL;
			_tmp19_ = gdk_get_default_root_window ();
			_tmp20_ = _g_object_ref0 (_tmp19_);
			window = _tmp20_;
			_tmp21_ = window;
			_tmp22_ = window;
			_tmp23_ = gdk_window_get_width (_tmp22_);
			_tmp24_ = window;
			_tmp25_ = gdk_window_get_height (_tmp24_);
			_tmp26_ = gdk_pixbuf_get_from_window (_tmp21_, 0, 0, _tmp23_, _tmp25_);
			_tmp27_ = _tmp26_;
			capture_screen_grabber_set_pixbuf (self, _tmp27_);
			_g_object_unref0 (_tmp27_);
			_tmp28_ = self->priv->_include_cursor;
			if (_tmp28_) {
				GdkWindow* _tmp29_ = NULL;
				GdkDisplay* _tmp30_ = NULL;
				GdkDeviceManager* _tmp31_ = NULL;
				GdkDevice* _tmp32_ = NULL;
				gint _tmp33_ = 0;
				gint _tmp34_ = 0;
				gint dx = 0;
				gint _tmp35_ = 0;
				gint dy = 0;
				gint _tmp36_ = 0;
				GdkPixbuf* _tmp37_ = NULL;
				GdkPixbuf* _tmp38_ = NULL;
				GdkPixbuf* _tmp39_ = NULL;
				gint _tmp40_ = 0;
				GdkPixbuf* _tmp41_ = NULL;
				gint _tmp42_ = 0;
				gint _tmp43_ = 0;
				gint _tmp44_ = 0;
				_tmp29_ = gdk_get_default_root_window ();
				_tmp30_ = gdk_display_get_default ();
				_tmp31_ = gdk_display_get_device_manager (_tmp30_);
				_tmp32_ = gdk_device_manager_get_client_pointer (_tmp31_);
				gdk_window_get_device_position (_tmp29_, _tmp32_, &_tmp33_, &_tmp34_, NULL);
				self->priv->cursor_x = _tmp33_;
				self->priv->cursor_y = _tmp34_;
				_tmp35_ = self->priv->cursor_x;
				dx = _tmp35_;
				_tmp36_ = self->priv->cursor_y;
				dy = _tmp36_;
				_tmp37_ = self->priv->cursor_pixbuf;
				_tmp38_ = self->priv->_pixbuf;
				_tmp39_ = self->priv->_pixbuf;
				_tmp40_ = gdk_pixbuf_get_width (_tmp39_);
				_tmp41_ = self->priv->_pixbuf;
				_tmp42_ = gdk_pixbuf_get_height (_tmp41_);
				_tmp43_ = dx;
				_tmp44_ = dy;
				gdk_pixbuf_composite (_tmp37_, _tmp38_, 0, 0, _tmp40_, _tmp42_, (gdouble) (_tmp43_ - 6), (gdouble) (_tmp44_ - 6), 1.0, 1.0, GDK_INTERP_BILINEAR, 255);
			}
			_tmp45_ = self->priv->_pixbuf;
			g_signal_emit_by_name (self, "grabbed", _tmp45_);
			_g_object_unref0 (window);
			break;
		}
		case CAPTURE_SCREEN_GRAB_MODE_WINDOW:
		{
			GdkWindow* window = NULL;
			GdkScreen* _tmp46_ = NULL;
			GdkWindow* _tmp47_ = NULL;
			gint winx = 0;
			gint winy = 0;
			GdkWindow* _tmp48_ = NULL;
			gint _tmp49_ = 0;
			gint _tmp50_ = 0;
			GdkWindow* _tmp51_ = NULL;
			GdkWindow* _tmp52_ = NULL;
			gint _tmp53_ = 0;
			GdkWindow* _tmp54_ = NULL;
			gint _tmp55_ = 0;
			GdkPixbuf* _tmp56_ = NULL;
			GdkPixbuf* _tmp57_ = NULL;
			gboolean _tmp58_ = FALSE;
			GdkPixbuf* _tmp77_ = NULL;
			_tmp46_ = self->priv->default_screen;
			_tmp47_ = gdk_screen_get_active_window (_tmp46_);
			window = _tmp47_;
			_tmp48_ = window;
			gdk_window_get_position (_tmp48_, &_tmp49_, &_tmp50_);
			winx = _tmp49_;
			winy = _tmp50_;
			_tmp51_ = window;
			_tmp52_ = window;
			_tmp53_ = gdk_window_get_width (_tmp52_);
			_tmp54_ = window;
			_tmp55_ = gdk_window_get_height (_tmp54_);
			_tmp56_ = gdk_pixbuf_get_from_window (_tmp51_, 0, 0, _tmp53_, _tmp55_);
			_tmp57_ = _tmp56_;
			capture_screen_grabber_set_pixbuf (self, _tmp57_);
			_g_object_unref0 (_tmp57_);
			_tmp58_ = self->priv->_include_cursor;
			if (_tmp58_) {
				GdkWindow* _tmp59_ = NULL;
				GdkDisplay* _tmp60_ = NULL;
				GdkDeviceManager* _tmp61_ = NULL;
				GdkDevice* _tmp62_ = NULL;
				gint _tmp63_ = 0;
				gint _tmp64_ = 0;
				gint dx = 0;
				gint _tmp65_ = 0;
				gint _tmp66_ = 0;
				gint dy = 0;
				gint _tmp67_ = 0;
				gint _tmp68_ = 0;
				GdkPixbuf* _tmp69_ = NULL;
				GdkPixbuf* _tmp70_ = NULL;
				GdkPixbuf* _tmp71_ = NULL;
				gint _tmp72_ = 0;
				GdkPixbuf* _tmp73_ = NULL;
				gint _tmp74_ = 0;
				gint _tmp75_ = 0;
				gint _tmp76_ = 0;
				_tmp59_ = gdk_get_default_root_window ();
				_tmp60_ = gdk_display_get_default ();
				_tmp61_ = gdk_display_get_device_manager (_tmp60_);
				_tmp62_ = gdk_device_manager_get_client_pointer (_tmp61_);
				gdk_window_get_device_position (_tmp59_, _tmp62_, &_tmp63_, &_tmp64_, NULL);
				self->priv->cursor_x = _tmp63_;
				self->priv->cursor_y = _tmp64_;
				_tmp65_ = self->priv->cursor_x;
				_tmp66_ = winx;
				dx = _tmp65_ - _tmp66_;
				_tmp67_ = self->priv->cursor_y;
				_tmp68_ = winy;
				dy = _tmp67_ - _tmp68_;
				_tmp69_ = self->priv->cursor_pixbuf;
				_tmp70_ = self->priv->_pixbuf;
				_tmp71_ = self->priv->_pixbuf;
				_tmp72_ = gdk_pixbuf_get_width (_tmp71_);
				_tmp73_ = self->priv->_pixbuf;
				_tmp74_ = gdk_pixbuf_get_height (_tmp73_);
				_tmp75_ = dx;
				_tmp76_ = dy;
				gdk_pixbuf_composite (_tmp69_, _tmp70_, 0, 0, _tmp72_, _tmp74_, (gdouble) (_tmp75_ - 6), (gdouble) (_tmp76_ - 6), 1.0, 1.0, GDK_INTERP_BILINEAR, 255);
			}
			_tmp77_ = self->priv->_pixbuf;
			g_signal_emit_by_name (self, "grabbed", _tmp77_);
			_g_object_unref0 (window);
			break;
		}
		case CAPTURE_SCREEN_GRAB_MODE_REGION:
		{
			GdkRectangle* _tmp78_ = NULL;
			GdkPixbuf* _tmp113_ = NULL;
			_tmp78_ = selection;
			if (_tmp78_ != NULL) {
				GdkWindow* window = NULL;
				GdkWindow* _tmp79_ = NULL;
				GdkWindow* _tmp80_ = NULL;
				GdkWindow* _tmp81_ = NULL;
				GdkRectangle* _tmp82_ = NULL;
				gint _tmp83_ = 0;
				GdkRectangle* _tmp84_ = NULL;
				gint _tmp85_ = 0;
				GdkRectangle* _tmp86_ = NULL;
				gint _tmp87_ = 0;
				GdkRectangle* _tmp88_ = NULL;
				gint _tmp89_ = 0;
				GdkPixbuf* _tmp90_ = NULL;
				GdkPixbuf* _tmp91_ = NULL;
				gboolean _tmp92_ = FALSE;
				_tmp79_ = gdk_get_default_root_window ();
				_tmp80_ = _g_object_ref0 (_tmp79_);
				window = _tmp80_;
				_tmp81_ = window;
				_tmp82_ = selection;
				_tmp83_ = (*_tmp82_).x;
				_tmp84_ = selection;
				_tmp85_ = (*_tmp84_).y;
				_tmp86_ = selection;
				_tmp87_ = (*_tmp86_).width;
				_tmp88_ = selection;
				_tmp89_ = (*_tmp88_).height;
				_tmp90_ = gdk_pixbuf_get_from_window (_tmp81_, _tmp83_, _tmp85_, _tmp87_, _tmp89_);
				_tmp91_ = _tmp90_;
				capture_screen_grabber_set_pixbuf (self, _tmp91_);
				_g_object_unref0 (_tmp91_);
				_tmp92_ = self->priv->_include_cursor;
				if (_tmp92_) {
					GdkWindow* _tmp93_ = NULL;
					GdkDisplay* _tmp94_ = NULL;
					GdkDeviceManager* _tmp95_ = NULL;
					GdkDevice* _tmp96_ = NULL;
					gint _tmp97_ = 0;
					gint _tmp98_ = 0;
					gint dx = 0;
					gint _tmp99_ = 0;
					GdkRectangle* _tmp100_ = NULL;
					gint _tmp101_ = 0;
					gint dy = 0;
					gint _tmp102_ = 0;
					GdkRectangle* _tmp103_ = NULL;
					gint _tmp104_ = 0;
					GdkPixbuf* _tmp105_ = NULL;
					GdkPixbuf* _tmp106_ = NULL;
					GdkPixbuf* _tmp107_ = NULL;
					gint _tmp108_ = 0;
					GdkPixbuf* _tmp109_ = NULL;
					gint _tmp110_ = 0;
					gint _tmp111_ = 0;
					gint _tmp112_ = 0;
					_tmp93_ = gdk_get_default_root_window ();
					_tmp94_ = gdk_display_get_default ();
					_tmp95_ = gdk_display_get_device_manager (_tmp94_);
					_tmp96_ = gdk_device_manager_get_client_pointer (_tmp95_);
					gdk_window_get_device_position (_tmp93_, _tmp96_, &_tmp97_, &_tmp98_, NULL);
					self->priv->cursor_x = _tmp97_;
					self->priv->cursor_y = _tmp98_;
					_tmp99_ = self->priv->cursor_x;
					_tmp100_ = selection;
					_tmp101_ = (*_tmp100_).x;
					dx = _tmp99_ - _tmp101_;
					_tmp102_ = self->priv->cursor_y;
					_tmp103_ = selection;
					_tmp104_ = (*_tmp103_).y;
					dy = _tmp102_ - _tmp104_;
					_tmp105_ = self->priv->cursor_pixbuf;
					_tmp106_ = self->priv->_pixbuf;
					_tmp107_ = self->priv->_pixbuf;
					_tmp108_ = gdk_pixbuf_get_width (_tmp107_);
					_tmp109_ = self->priv->_pixbuf;
					_tmp110_ = gdk_pixbuf_get_height (_tmp109_);
					_tmp111_ = dx;
					_tmp112_ = dy;
					gdk_pixbuf_composite (_tmp105_, _tmp106_, 0, 0, _tmp108_, _tmp110_, (gdouble) (_tmp111_ - 6), (gdouble) (_tmp112_ - 6), 1.0, 1.0, GDK_INTERP_BILINEAR, 255);
				}
				_g_object_unref0 (window);
			}
			_tmp113_ = self->priv->_pixbuf;
			g_signal_emit_by_name (self, "grabbed", _tmp113_);
			break;
		}
		default:
		{
			break;
		}
	}
	_tmp114_ = self->priv->_pixbuf;
	_tmp115_ = _g_object_ref0 (_tmp114_);
	result = _tmp115_;
	return result;
}


CaptureScreenGrabber* capture_screen_grabber_construct_from_region (GType object_type, gboolean include_cursor) {
	CaptureScreenGrabber* self = NULL;
	gboolean _tmp0_ = FALSE;
	_tmp0_ = include_cursor;
	self = (CaptureScreenGrabber*) capture_screen_grabber_construct (object_type, CAPTURE_SCREEN_GRAB_MODE_REGION, _tmp0_);
	return self;
}


CaptureScreenGrabber* capture_screen_grabber_new_from_region (gboolean include_cursor) {
	return capture_screen_grabber_construct_from_region (CAPTURE_TYPE_SCREEN_GRABBER, include_cursor);
}


CaptureScreenGrabber* capture_screen_grabber_construct_from_window (GType object_type, gboolean include_cursor) {
	CaptureScreenGrabber* self = NULL;
	gboolean _tmp0_ = FALSE;
	_tmp0_ = include_cursor;
	self = (CaptureScreenGrabber*) capture_screen_grabber_construct (object_type, CAPTURE_SCREEN_GRAB_MODE_WINDOW, _tmp0_);
	return self;
}


CaptureScreenGrabber* capture_screen_grabber_new_from_window (gboolean include_cursor) {
	return capture_screen_grabber_construct_from_window (CAPTURE_TYPE_SCREEN_GRABBER, include_cursor);
}


CaptureScreenGrabber* capture_screen_grabber_construct_from_desktop (GType object_type, gboolean include_cursor) {
	CaptureScreenGrabber* self = NULL;
	gboolean _tmp0_ = FALSE;
	_tmp0_ = include_cursor;
	self = (CaptureScreenGrabber*) capture_screen_grabber_construct (object_type, CAPTURE_SCREEN_GRAB_MODE_DESKTOP, _tmp0_);
	return self;
}


CaptureScreenGrabber* capture_screen_grabber_new_from_desktop (gboolean include_cursor) {
	return capture_screen_grabber_construct_from_desktop (CAPTURE_TYPE_SCREEN_GRABBER, include_cursor);
}


gboolean capture_screen_grabber_get_include_cursor (CaptureScreenGrabber* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_include_cursor;
	result = _tmp0_;
	return result;
}


void capture_screen_grabber_set_include_cursor (CaptureScreenGrabber* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_include_cursor = _tmp0_;
}


GdkPixbuf* capture_screen_grabber_get_pixbuf (CaptureScreenGrabber* self) {
	GdkPixbuf* result;
	GdkPixbuf* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_pixbuf;
	result = _tmp0_;
	return result;
}


void capture_screen_grabber_set_pixbuf (CaptureScreenGrabber* self, GdkPixbuf* value) {
	GdkPixbuf* _tmp0_ = NULL;
	GdkPixbuf* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_pixbuf);
	self->priv->_pixbuf = _tmp1_;
}


CaptureScreenGrabMode capture_screen_grabber_get_mode (CaptureScreenGrabber* self) {
	CaptureScreenGrabMode result;
	CaptureScreenGrabMode _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_mode;
	result = _tmp0_;
	return result;
}


void capture_screen_grabber_set_mode (CaptureScreenGrabber* self, CaptureScreenGrabMode value) {
	CaptureScreenGrabMode _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_mode = _tmp0_;
}


static void capture_value_screen_grabber_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void capture_value_screen_grabber_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		capture_screen_grabber_unref (value->data[0].v_pointer);
	}
}


static void capture_value_screen_grabber_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = capture_screen_grabber_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer capture_value_screen_grabber_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* capture_value_screen_grabber_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		CaptureScreenGrabber* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = capture_screen_grabber_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* capture_value_screen_grabber_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	CaptureScreenGrabber** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = capture_screen_grabber_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* capture_param_spec_screen_grabber (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	CaptureParamSpecScreenGrabber* spec;
	g_return_val_if_fail (g_type_is_a (object_type, CAPTURE_TYPE_SCREEN_GRABBER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer capture_value_get_screen_grabber (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CAPTURE_TYPE_SCREEN_GRABBER), NULL);
	return value->data[0].v_pointer;
}


void capture_value_set_screen_grabber (GValue* value, gpointer v_object) {
	CaptureScreenGrabber* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CAPTURE_TYPE_SCREEN_GRABBER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, CAPTURE_TYPE_SCREEN_GRABBER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		capture_screen_grabber_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		capture_screen_grabber_unref (old);
	}
}


void capture_value_take_screen_grabber (GValue* value, gpointer v_object) {
	CaptureScreenGrabber* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CAPTURE_TYPE_SCREEN_GRABBER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, CAPTURE_TYPE_SCREEN_GRABBER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		capture_screen_grabber_unref (old);
	}
}


static void capture_screen_grabber_class_init (CaptureScreenGrabberClass * klass) {
	capture_screen_grabber_parent_class = g_type_class_peek_parent (klass);
	((CaptureScreenGrabberClass *) klass)->finalize = capture_screen_grabber_finalize;
	g_type_class_add_private (klass, sizeof (CaptureScreenGrabberPrivate));
	g_signal_new ("grabbed", CAPTURE_TYPE_SCREEN_GRABBER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, gdk_pixbuf_get_type ());
}


static void capture_screen_grabber_instance_init (CaptureScreenGrabber * self) {
	self->priv = CAPTURE_SCREEN_GRABBER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void capture_screen_grabber_finalize (CaptureScreenGrabber* obj) {
	CaptureScreenGrabber * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CAPTURE_TYPE_SCREEN_GRABBER, CaptureScreenGrabber);
	g_signal_handlers_destroy (self);
	_g_object_unref0 (self->priv->default_display);
	_g_object_unref0 (self->priv->default_screen);
	_g_object_unref0 (self->priv->cursor_pixbuf);
	_g_object_unref0 (self->priv->_pixbuf);
}


GType capture_screen_grabber_get_type (void) {
	static volatile gsize capture_screen_grabber_type_id__volatile = 0;
	if (g_once_init_enter (&capture_screen_grabber_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { capture_value_screen_grabber_init, capture_value_screen_grabber_free_value, capture_value_screen_grabber_copy_value, capture_value_screen_grabber_peek_pointer, "p", capture_value_screen_grabber_collect_value, "p", capture_value_screen_grabber_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (CaptureScreenGrabberClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) capture_screen_grabber_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CaptureScreenGrabber), 0, (GInstanceInitFunc) capture_screen_grabber_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType capture_screen_grabber_type_id;
		capture_screen_grabber_type_id = g_type_register_fundamental (g_type_fundamental_next (), "CaptureScreenGrabber", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&capture_screen_grabber_type_id__volatile, capture_screen_grabber_type_id);
	}
	return capture_screen_grabber_type_id__volatile;
}


gpointer capture_screen_grabber_ref (gpointer instance) {
	CaptureScreenGrabber* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void capture_screen_grabber_unref (gpointer instance) {
	CaptureScreenGrabber* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		CAPTURE_SCREEN_GRABBER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



