/* CaptureDockItem.c generated by valac 0.34.4, the Vala compiler
 * generated from CaptureDockItem.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <plank.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <gio/gio.h>
#include <gee.h>
#include <glib/gi18n-lib.h>
#include <granite.h>
#include <float.h>
#include <math.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <libnotify/notify.h>
#include <locale.h>


#define CAPTURE_TYPE_CAPTURE_MODE (capture_capture_mode_get_type ())

#define CAPTURE_TYPE_CAPTURE_DOCK_ITEM (capture_capture_dock_item_get_type ())
#define CAPTURE_CAPTURE_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CAPTURE_TYPE_CAPTURE_DOCK_ITEM, CaptureCaptureDockItem))
#define CAPTURE_CAPTURE_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CAPTURE_TYPE_CAPTURE_DOCK_ITEM, CaptureCaptureDockItemClass))
#define CAPTURE_IS_CAPTURE_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CAPTURE_TYPE_CAPTURE_DOCK_ITEM))
#define CAPTURE_IS_CAPTURE_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CAPTURE_TYPE_CAPTURE_DOCK_ITEM))
#define CAPTURE_CAPTURE_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CAPTURE_TYPE_CAPTURE_DOCK_ITEM, CaptureCaptureDockItemClass))

typedef struct _CaptureCaptureDockItem CaptureCaptureDockItem;
typedef struct _CaptureCaptureDockItemClass CaptureCaptureDockItemClass;
typedef struct _CaptureCaptureDockItemPrivate CaptureCaptureDockItemPrivate;

#define CAPTURE_TYPE_SCREEN_GRAB_MODE (capture_screen_grab_mode_get_type ())

#define CAPTURE_TYPE_SEQUENCE (capture_sequence_get_type ())
#define CAPTURE_SEQUENCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CAPTURE_TYPE_SEQUENCE, CaptureSequence))
#define CAPTURE_SEQUENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CAPTURE_TYPE_SEQUENCE, CaptureSequenceClass))
#define CAPTURE_IS_SEQUENCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CAPTURE_TYPE_SEQUENCE))
#define CAPTURE_IS_SEQUENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CAPTURE_TYPE_SEQUENCE))
#define CAPTURE_SEQUENCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CAPTURE_TYPE_SEQUENCE, CaptureSequenceClass))

typedef struct _CaptureSequence CaptureSequence;
typedef struct _CaptureSequenceClass CaptureSequenceClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) ((var == NULL) ? NULL : (var = (g_free (var), NULL)))
#define _capture_sequence_unref0(var) ((var == NULL) ? NULL : (var = (capture_sequence_unref (var), NULL)))

#define CAPTURE_TYPE_SETTINGS_DIALOG (capture_settings_dialog_get_type ())
#define CAPTURE_SETTINGS_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CAPTURE_TYPE_SETTINGS_DIALOG, CaptureSettingsDialog))
#define CAPTURE_SETTINGS_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CAPTURE_TYPE_SETTINGS_DIALOG, CaptureSettingsDialogClass))
#define CAPTURE_IS_SETTINGS_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CAPTURE_TYPE_SETTINGS_DIALOG))
#define CAPTURE_IS_SETTINGS_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CAPTURE_TYPE_SETTINGS_DIALOG))
#define CAPTURE_SETTINGS_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CAPTURE_TYPE_SETTINGS_DIALOG, CaptureSettingsDialogClass))

typedef struct _CaptureSettingsDialog CaptureSettingsDialog;
typedef struct _CaptureSettingsDialogClass CaptureSettingsDialogClass;

#define CAPTURE_TYPE_REGION_SELECT (capture_region_select_get_type ())
#define CAPTURE_REGION_SELECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CAPTURE_TYPE_REGION_SELECT, CaptureRegionSelect))
#define CAPTURE_REGION_SELECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CAPTURE_TYPE_REGION_SELECT, CaptureRegionSelectClass))
#define CAPTURE_IS_REGION_SELECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CAPTURE_TYPE_REGION_SELECT))
#define CAPTURE_IS_REGION_SELECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CAPTURE_TYPE_REGION_SELECT))
#define CAPTURE_REGION_SELECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CAPTURE_TYPE_REGION_SELECT, CaptureRegionSelectClass))

typedef struct _CaptureRegionSelect CaptureRegionSelect;
typedef struct _CaptureRegionSelectClass CaptureRegionSelectClass;

#define CAPTURE_TYPE_COUNTDOWN (capture_countdown_get_type ())
#define CAPTURE_COUNTDOWN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CAPTURE_TYPE_COUNTDOWN, CaptureCountdown))
#define CAPTURE_COUNTDOWN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CAPTURE_TYPE_COUNTDOWN, CaptureCountdownClass))
#define CAPTURE_IS_COUNTDOWN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CAPTURE_TYPE_COUNTDOWN))
#define CAPTURE_IS_COUNTDOWN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CAPTURE_TYPE_COUNTDOWN))
#define CAPTURE_COUNTDOWN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CAPTURE_TYPE_COUNTDOWN, CaptureCountdownClass))

typedef struct _CaptureCountdown CaptureCountdown;
typedef struct _CaptureCountdownClass CaptureCountdownClass;
#define _capture_countdown_unref0(var) ((var == NULL) ? NULL : (var = (capture_countdown_unref (var), NULL)))

#define CAPTURE_TYPE_SCREEN_GRABBER (capture_screen_grabber_get_type ())
#define CAPTURE_SCREEN_GRABBER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CAPTURE_TYPE_SCREEN_GRABBER, CaptureScreenGrabber))
#define CAPTURE_SCREEN_GRABBER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CAPTURE_TYPE_SCREEN_GRABBER, CaptureScreenGrabberClass))
#define CAPTURE_IS_SCREEN_GRABBER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CAPTURE_TYPE_SCREEN_GRABBER))
#define CAPTURE_IS_SCREEN_GRABBER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CAPTURE_TYPE_SCREEN_GRABBER))
#define CAPTURE_SCREEN_GRABBER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CAPTURE_TYPE_SCREEN_GRABBER, CaptureScreenGrabberClass))

typedef struct _CaptureScreenGrabber CaptureScreenGrabber;
typedef struct _CaptureScreenGrabberClass CaptureScreenGrabberClass;
#define _capture_screen_grabber_unref0(var) ((var == NULL) ? NULL : (var = (capture_screen_grabber_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

#define CAPTURE_TYPE_CAPTURE_PREVIEW (capture_capture_preview_get_type ())
#define CAPTURE_CAPTURE_PREVIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CAPTURE_TYPE_CAPTURE_PREVIEW, CaptureCapturePreview))
#define CAPTURE_CAPTURE_PREVIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CAPTURE_TYPE_CAPTURE_PREVIEW, CaptureCapturePreviewClass))
#define CAPTURE_IS_CAPTURE_PREVIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CAPTURE_TYPE_CAPTURE_PREVIEW))
#define CAPTURE_IS_CAPTURE_PREVIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CAPTURE_TYPE_CAPTURE_PREVIEW))
#define CAPTURE_CAPTURE_PREVIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CAPTURE_TYPE_CAPTURE_PREVIEW, CaptureCapturePreviewClass))

typedef struct _CaptureCapturePreview CaptureCapturePreview;
typedef struct _CaptureCapturePreviewClass CaptureCapturePreviewClass;

typedef enum  {
	CAPTURE_CAPTURE_MODE_SCREENSHOT,
	CAPTURE_CAPTURE_MODE_SCREENCAST
} CaptureCaptureMode;

struct _CaptureCaptureDockItem {
	PlankDockletItem parent_instance;
	CaptureCaptureDockItemPrivate * priv;
};

struct _CaptureCaptureDockItemClass {
	PlankDockletItemClass parent_class;
};

typedef enum  {
	CAPTURE_SCREEN_GRAB_MODE_DESKTOP,
	CAPTURE_SCREEN_GRAB_MODE_WINDOW,
	CAPTURE_SCREEN_GRAB_MODE_REGION
} CaptureScreenGrabMode;

struct _CaptureCaptureDockItemPrivate {
	CaptureScreenGrabMode mode;
	GtkClipboard* clipboard;
	GdkRectangle* selection;
	CaptureSequence* sequence;
	GSettings* settings;
	gboolean capturing;
	CaptureCaptureMode capture_mode;
};

struct _Block1Data {
	int _ref_count_;
	CaptureCaptureDockItem* self;
	CaptureScreenGrabber* grabber;
	gint framerate;
	gdouble duration;
};


static gpointer capture_capture_dock_item_parent_class = NULL;

#define GETTEXT_PACKAGE "capture"
GType capture_capture_mode_get_type (void) G_GNUC_CONST;
GType capture_capture_dock_item_get_type (void) G_GNUC_CONST;
GType capture_screen_grab_mode_get_type (void) G_GNUC_CONST;
gpointer capture_sequence_ref (gpointer instance);
void capture_sequence_unref (gpointer instance);
GParamSpec* capture_param_spec_sequence (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void capture_value_set_sequence (GValue* value, gpointer v_object);
void capture_value_take_sequence (GValue* value, gpointer v_object);
gpointer capture_value_get_sequence (const GValue* value);
GType capture_sequence_get_type (void) G_GNUC_CONST;
#define CAPTURE_CAPTURE_DOCK_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CAPTURE_TYPE_CAPTURE_DOCK_ITEM, CaptureCaptureDockItemPrivate))
enum  {
	CAPTURE_CAPTURE_DOCK_ITEM_DUMMY_PROPERTY
};
CaptureCaptureDockItem* capture_capture_dock_item_new_with_dockitem_file (GFile* file);
CaptureCaptureDockItem* capture_capture_dock_item_construct_with_dockitem_file (GType object_type, GFile* file);
void capture_capture_dock_item_switch_capture_mode (CaptureCaptureDockItem* self, CaptureCaptureMode mode);
static GeeArrayList* capture_capture_dock_item_real_get_menu_items (PlankDockElement* base);
static void __lambda8_ (CaptureCaptureDockItem* self);
static void ___lambda8__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda9_ (CaptureCaptureDockItem* self);
static void ___lambda9__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void __lambda10_ (CaptureCaptureDockItem* self);
GType capture_settings_dialog_get_type (void) G_GNUC_CONST;
CaptureSettingsDialog* capture_settings_dialog_new (void);
CaptureSettingsDialog* capture_settings_dialog_construct (GType object_type);
static void ___lambda10__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
void capture_capture_dock_item_take_screenshot (CaptureCaptureDockItem* self, CaptureScreenGrabMode* mode);
GType capture_region_select_get_type (void) G_GNUC_CONST;
CaptureRegionSelect* capture_region_select_new (void);
CaptureRegionSelect* capture_region_select_construct (GType object_type);
GtkResponseType capture_region_select_run (CaptureRegionSelect* self);
void capture_region_select_get_selection (CaptureRegionSelect* self, GdkRectangle* result);
static GdkRectangle* _gdk_rectangle_dup (GdkRectangle* self);
gpointer capture_countdown_ref (gpointer instance);
void capture_countdown_unref (gpointer instance);
GParamSpec* capture_param_spec_countdown (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void capture_value_set_countdown (GValue* value, gpointer v_object);
void capture_value_take_countdown (GValue* value, gpointer v_object);
gpointer capture_value_get_countdown (const GValue* value);
GType capture_countdown_get_type (void) G_GNUC_CONST;
CaptureCountdown* capture_countdown_new (gint seconds);
CaptureCountdown* capture_countdown_construct (GType object_type, gint seconds);
static void __lambda24_ (CaptureCaptureDockItem* self, gint second, gdouble progress);
static void ___lambda24__capture_countdown_tick (CaptureCountdown* _sender, gint second, gdouble progress, gpointer self);
static void __lambda25_ (CaptureCaptureDockItem* self);
void capture_capture_dock_item_shot (CaptureCaptureDockItem* self);
static void ___lambda25__capture_countdown_ignition (CaptureCountdown* _sender, gpointer self);
void capture_countdown_start (CaptureCountdown* self);
gpointer capture_screen_grabber_ref (gpointer instance);
void capture_screen_grabber_unref (gpointer instance);
GParamSpec* capture_param_spec_screen_grabber (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void capture_value_set_screen_grabber (GValue* value, gpointer v_object);
void capture_value_take_screen_grabber (GValue* value, gpointer v_object);
gpointer capture_value_get_screen_grabber (const GValue* value);
GType capture_screen_grabber_get_type (void) G_GNUC_CONST;
CaptureScreenGrabber* capture_screen_grabber_new_from_region (gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_construct_from_region (GType object_type, gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_new_from_window (gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_construct_from_window (GType object_type, gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_new_from_desktop (gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_construct_from_desktop (GType object_type, gboolean include_cursor);
GdkPixbuf* capture_screen_grabber_grab (CaptureScreenGrabber* self, GdkRectangle* selection);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
void capture_capture_dock_item_take_screencapture (CaptureCaptureDockItem* self, CaptureScreenGrabMode mode);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
CaptureSequence* capture_sequence_new (void);
CaptureSequence* capture_sequence_construct (GType object_type);
void capture_sequence_set_framerate (CaptureSequence* self, guint value);
CaptureScreenGrabber* capture_screen_grabber_new (CaptureScreenGrabMode mode, gboolean include_cursor);
CaptureScreenGrabber* capture_screen_grabber_construct (GType object_type, CaptureScreenGrabMode mode, gboolean include_cursor);
static gboolean __lambda26_ (Block1Data* _data1_);
void capture_sequence_add (CaptureSequence* self, GdkPixbuf* pixbuf);
GType capture_capture_preview_get_type (void) G_GNUC_CONST;
CaptureCapturePreview* capture_capture_preview_new (CaptureSequence* sequence);
CaptureCapturePreview* capture_capture_preview_construct (GType object_type, CaptureSequence* sequence);
gboolean capture_sequence_save_to_animated_gif (CaptureSequence* self, const gchar* filename);
static gboolean ___lambda26__gsource_func (gpointer self);
static PlankAnimationType capture_capture_dock_item_real_on_scrolled (PlankDockElement* base, GdkScrollDirection dir, GdkModifierType mod, guint32 event_time);
static PlankAnimationType capture_capture_dock_item_real_on_clicked (PlankDockElement* base, PlankPopupButton button, GdkModifierType mod, guint32 event_time);
CaptureCaptureDockItem* capture_capture_dock_item_new (void);
CaptureCaptureDockItem* capture_capture_dock_item_construct (GType object_type);
static GObject * capture_capture_dock_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void capture_capture_dock_item_finalize (GObject* obj);


GType capture_capture_mode_get_type (void) {
	static volatile gsize capture_capture_mode_type_id__volatile = 0;
	if (g_once_init_enter (&capture_capture_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{CAPTURE_CAPTURE_MODE_SCREENSHOT, "CAPTURE_CAPTURE_MODE_SCREENSHOT", "screenshot"}, {CAPTURE_CAPTURE_MODE_SCREENCAST, "CAPTURE_CAPTURE_MODE_SCREENCAST", "screencast"}, {0, NULL, NULL}};
		GType capture_capture_mode_type_id;
		capture_capture_mode_type_id = g_enum_register_static ("CaptureCaptureMode", values);
		g_once_init_leave (&capture_capture_mode_type_id__volatile, capture_capture_mode_type_id);
	}
	return capture_capture_mode_type_id__volatile;
}


CaptureCaptureDockItem* capture_capture_dock_item_construct_with_dockitem_file (GType object_type, GFile* file) {
	CaptureCaptureDockItem * self = NULL;
	g_return_val_if_fail (file != NULL, NULL);
	self = (CaptureCaptureDockItem*) plank_docklet_item_construct (object_type);
	return self;
}


CaptureCaptureDockItem* capture_capture_dock_item_new_with_dockitem_file (GFile* file) {
	return capture_capture_dock_item_construct_with_dockitem_file (CAPTURE_TYPE_CAPTURE_DOCK_ITEM, file);
}


void capture_capture_dock_item_switch_capture_mode (CaptureCaptureDockItem* self, CaptureCaptureMode mode) {
	CaptureCaptureMode _tmp0_ = 0;
	CaptureCaptureMode _tmp1_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = mode;
	self->priv->capture_mode = _tmp0_;
	_tmp1_ = self->priv->capture_mode;
	switch (_tmp1_) {
		case CAPTURE_CAPTURE_MODE_SCREENCAST:
		{
			GSettings* _tmp2_ = NULL;
			plank_dock_item_set_Icon ((PlankDockItem*) self, "camera-video-symbolic");
			_tmp2_ = self->priv->settings;
			g_settings_set_string (_tmp2_, "mode", "Screencast");
			break;
		}
		case CAPTURE_CAPTURE_MODE_SCREENSHOT:
		{
			GSettings* _tmp3_ = NULL;
			plank_dock_item_set_Icon ((PlankDockItem*) self, "camera-photo-symbolic");
			_tmp3_ = self->priv->settings;
			g_settings_set_string (_tmp3_, "mode", "Screenshot");
			break;
		}
		default:
		break;
	}
}


static void __lambda8_ (CaptureCaptureDockItem* self) {
	capture_capture_dock_item_switch_capture_mode (self, CAPTURE_CAPTURE_MODE_SCREENSHOT);
}


static void ___lambda8__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda8_ ((CaptureCaptureDockItem*) self);
}


static void __lambda9_ (CaptureCaptureDockItem* self) {
	capture_capture_dock_item_switch_capture_mode (self, CAPTURE_CAPTURE_MODE_SCREENCAST);
}


static void ___lambda9__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda9_ ((CaptureCaptureDockItem*) self);
}


static void __lambda10_ (CaptureCaptureDockItem* self) {
	const gchar* _tmp0_ = NULL;
	CaptureSettingsDialog* dlg = NULL;
	CaptureSettingsDialog* _tmp1_ = NULL;
	_tmp0_ = _ ("Settings");
	plank_logger_notification (_tmp0_, "");
	_tmp1_ = capture_settings_dialog_new ();
	g_object_ref_sink (_tmp1_);
	dlg = _tmp1_;
	gtk_dialog_run ((GtkDialog*) dlg);
	gtk_widget_destroy ((GtkWidget*) dlg);
	_g_object_unref0 (dlg);
}


static void ___lambda10__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda10_ ((CaptureCaptureDockItem*) self);
}


static GeeArrayList* capture_capture_dock_item_real_get_menu_items (PlankDockElement* base) {
	CaptureCaptureDockItem * self;
	GeeArrayList* result = NULL;
	GeeArrayList* items = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GtkMenuItem* item = NULL;
	const gchar* _tmp1_ = NULL;
	GtkMenuItem* _tmp2_ = NULL;
	GtkMenuItem* _tmp3_ = NULL;
	GtkMenuItem* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	GtkMenuItem* _tmp6_ = NULL;
	GtkMenuItem* _tmp7_ = NULL;
	GtkMenuItem* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	GtkMenuItem* _tmp10_ = NULL;
	GtkMenuItem* _tmp11_ = NULL;
	GtkMenuItem* _tmp12_ = NULL;
	self = (CaptureCaptureDockItem*) base;
	_tmp0_ = gee_array_list_new (gtk_menu_item_get_type (), (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	items = _tmp0_;
	_tmp1_ = _ ("Screenshot");
	_tmp2_ = plank_dock_element_create_menu_item (_tmp1_, "", TRUE);
	_g_object_unref0 (item);
	item = _tmp2_;
	_tmp3_ = item;
	g_signal_connect_object (_tmp3_, "activate", (GCallback) ___lambda8__gtk_menu_item_activate, self, 0);
	_tmp4_ = item;
	gee_abstract_collection_add ((GeeAbstractCollection*) items, _tmp4_);
	_tmp5_ = _ ("Screencast");
	_tmp6_ = plank_dock_element_create_menu_item (_tmp5_, "", TRUE);
	_g_object_unref0 (item);
	item = _tmp6_;
	_tmp7_ = item;
	g_signal_connect_object (_tmp7_, "activate", (GCallback) ___lambda9__gtk_menu_item_activate, self, 0);
	_tmp8_ = item;
	gee_abstract_collection_add ((GeeAbstractCollection*) items, _tmp8_);
	_tmp9_ = _ ("Settings");
	_tmp10_ = plank_dock_element_create_menu_item (_tmp9_, "", TRUE);
	_g_object_unref0 (item);
	item = _tmp10_;
	_tmp11_ = item;
	g_signal_connect_object (_tmp11_, "activate", (GCallback) ___lambda10__gtk_menu_item_activate, self, 0);
	_tmp12_ = item;
	gee_abstract_collection_add ((GeeAbstractCollection*) items, _tmp12_);
	result = items;
	_g_object_unref0 (item);
	return result;
}


static GdkRectangle* _gdk_rectangle_dup (GdkRectangle* self) {
	GdkRectangle* dup;
	dup = g_new0 (GdkRectangle, 1);
	memcpy (dup, self, sizeof (GdkRectangle));
	return dup;
}


static gpointer __gdk_rectangle_dup0 (gpointer self) {
	return self ? _gdk_rectangle_dup (self) : NULL;
}


static void __lambda24_ (CaptureCaptureDockItem* self, gint second, gdouble progress) {
	gint _tmp0_ = 0;
	gdouble _tmp1_ = 0.0;
	_tmp0_ = second;
	plank_dock_item_set_Count ((PlankDockItem*) self, (gint64) _tmp0_);
	_tmp1_ = progress;
	plank_dock_item_set_Progress ((PlankDockItem*) self, _tmp1_);
}


static void ___lambda24__capture_countdown_tick (CaptureCountdown* _sender, gint second, gdouble progress, gpointer self) {
	__lambda24_ ((CaptureCaptureDockItem*) self, second, progress);
}


static void __lambda25_ (CaptureCaptureDockItem* self) {
	capture_capture_dock_item_shot (self);
	plank_dock_item_set_ProgressVisible ((PlankDockItem*) self, FALSE);
	plank_dock_item_set_CountVisible ((PlankDockItem*) self, FALSE);
}


static void ___lambda25__capture_countdown_ignition (CaptureCountdown* _sender, gpointer self) {
	__lambda25_ ((CaptureCaptureDockItem*) self);
}


void capture_capture_dock_item_take_screenshot (CaptureCaptureDockItem* self, CaptureScreenGrabMode* mode) {
	CaptureScreenGrabMode* _tmp0_ = NULL;
	CaptureRegionSelect* region_select = NULL;
	CaptureScreenGrabMode _tmp2_ = 0;
	gint c = 0;
	GSettings* _tmp11_ = NULL;
	gint _tmp12_ = 0;
	CaptureCountdown* countdown = NULL;
	gint _tmp13_ = 0;
	CaptureCountdown* _tmp14_ = NULL;
	gint _tmp15_ = 0;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_ = NULL;
	gint _tmp18_ = 0;
	CaptureCountdown* _tmp19_ = NULL;
	CaptureCountdown* _tmp20_ = NULL;
	CaptureCountdown* _tmp21_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = mode;
	if (_tmp0_ != NULL) {
		CaptureScreenGrabMode* _tmp1_ = NULL;
		_tmp1_ = mode;
		self->priv->mode = *_tmp1_;
	}
	region_select = NULL;
	_g_free0 (self->priv->selection);
	self->priv->selection = NULL;
	_tmp2_ = self->priv->mode;
	if (_tmp2_ == CAPTURE_SCREEN_GRAB_MODE_REGION) {
		CaptureRegionSelect* _tmp3_ = NULL;
		GtkResponseType response = 0;
		CaptureRegionSelect* _tmp4_ = NULL;
		GtkResponseType _tmp5_ = 0;
		CaptureRegionSelect* _tmp6_ = NULL;
		GtkResponseType _tmp7_ = 0;
		CaptureRegionSelect* _tmp8_ = NULL;
		GdkRectangle _tmp9_ = {0};
		GdkRectangle* _tmp10_ = NULL;
		_tmp3_ = capture_region_select_new ();
		g_object_ref_sink (_tmp3_);
		_g_object_unref0 (region_select);
		region_select = _tmp3_;
		_tmp4_ = region_select;
		_tmp5_ = capture_region_select_run (_tmp4_);
		response = _tmp5_;
		_tmp6_ = region_select;
		gtk_widget_destroy ((GtkWidget*) _tmp6_);
		_tmp7_ = response;
		if (_tmp7_ == GTK_RESPONSE_CANCEL) {
			_g_object_unref0 (region_select);
			return;
		}
		_tmp8_ = region_select;
		capture_region_select_get_selection (_tmp8_, &_tmp9_);
		_tmp10_ = __gdk_rectangle_dup0 (&_tmp9_);
		_g_free0 (self->priv->selection);
		self->priv->selection = _tmp10_;
	}
	plank_dock_item_set_ProgressVisible ((PlankDockItem*) self, TRUE);
	plank_dock_item_set_CountVisible ((PlankDockItem*) self, TRUE);
	plank_dock_item_set_Progress ((PlankDockItem*) self, (gdouble) 0);
	_tmp11_ = self->priv->settings;
	_tmp12_ = g_settings_get_int (_tmp11_, "countdown");
	c = _tmp12_;
	_tmp13_ = c;
	_tmp14_ = capture_countdown_new (_tmp13_);
	countdown = _tmp14_;
	_tmp15_ = c;
	_tmp16_ = g_strdup_printf ("countdown = %u", (guint) _tmp15_);
	_tmp17_ = _tmp16_;
	plank_logger_notification (_tmp17_, "");
	_g_free0 (_tmp17_);
	_tmp18_ = c;
	plank_dock_item_set_Count ((PlankDockItem*) self, (gint64) _tmp18_);
	_tmp19_ = countdown;
	g_signal_connect_object (_tmp19_, "tick", (GCallback) ___lambda24__capture_countdown_tick, self, 0);
	_tmp20_ = countdown;
	g_signal_connect_object (_tmp20_, "ignition", (GCallback) ___lambda25__capture_countdown_ignition, self, 0);
	_tmp21_ = countdown;
	capture_countdown_start (_tmp21_);
	_capture_countdown_unref0 (countdown);
	_g_object_unref0 (region_select);
}


static gchar* g_date_time_to_string (GDateTime* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_date_time_format (self, "%FT%H:%M:%S%z");
	result = _tmp0_;
	return result;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


void capture_capture_dock_item_shot (CaptureCaptureDockItem* self) {
	CaptureScreenGrabber* grabber = NULL;
	GdkPixbuf* pixbuf = NULL;
	CaptureScreenGrabMode _tmp0_ = 0;
	CaptureScreenGrabber* _tmp11_ = NULL;
	GdkRectangle* _tmp12_ = NULL;
	GdkPixbuf* _tmp13_ = NULL;
	GdkPixbuf* _tmp14_ = NULL;
	GDateTime* now = NULL;
	GDateTime* _tmp15_ = NULL;
	gchar* name = NULL;
	const gchar* _tmp16_ = NULL;
	GDateTime* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_ = NULL;
	gchar* filename = NULL;
	GSettings* _tmp22_ = NULL;
	gboolean _tmp23_ = FALSE;
	const gchar* _tmp38_ = NULL;
	GSettings* _tmp62_ = NULL;
	gboolean _tmp63_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->mode;
	switch (_tmp0_) {
		case CAPTURE_SCREEN_GRAB_MODE_REGION:
		{
			GSettings* _tmp1_ = NULL;
			gboolean _tmp2_ = FALSE;
			CaptureScreenGrabber* _tmp3_ = NULL;
			_tmp1_ = self->priv->settings;
			_tmp2_ = g_settings_get_boolean (_tmp1_, "include-pointer");
			_tmp3_ = capture_screen_grabber_new_from_region (_tmp2_);
			_capture_screen_grabber_unref0 (grabber);
			grabber = _tmp3_;
			break;
		}
		case CAPTURE_SCREEN_GRAB_MODE_WINDOW:
		{
			GSettings* _tmp4_ = NULL;
			gboolean _tmp5_ = FALSE;
			CaptureScreenGrabber* _tmp6_ = NULL;
			_tmp4_ = self->priv->settings;
			_tmp5_ = g_settings_get_boolean (_tmp4_, "include-pointer");
			_tmp6_ = capture_screen_grabber_new_from_window (_tmp5_);
			_capture_screen_grabber_unref0 (grabber);
			grabber = _tmp6_;
			break;
		}
		case CAPTURE_SCREEN_GRAB_MODE_DESKTOP:
		{
			GSettings* _tmp7_ = NULL;
			gboolean _tmp8_ = FALSE;
			CaptureScreenGrabber* _tmp9_ = NULL;
			_tmp7_ = self->priv->settings;
			_tmp8_ = g_settings_get_boolean (_tmp7_, "include-pointer");
			_tmp9_ = capture_screen_grabber_new_from_desktop (_tmp8_);
			_capture_screen_grabber_unref0 (grabber);
			grabber = _tmp9_;
			break;
		}
		default:
		{
			CaptureScreenGrabMode _tmp10_ = 0;
			_tmp10_ = self->priv->mode;
			g_warning ("CaptureDockItem.vala:204: Illegal ScreenGrabMode: %u", (guint) _tmp10_);
			_g_object_unref0 (pixbuf);
			_capture_screen_grabber_unref0 (grabber);
			return;
		}
	}
	_tmp11_ = grabber;
	_tmp12_ = self->priv->selection;
	_tmp13_ = capture_screen_grabber_grab (_tmp11_, _tmp12_);
	_g_object_unref0 (pixbuf);
	pixbuf = _tmp13_;
	_tmp14_ = pixbuf;
	if (_tmp14_ == NULL) {
		plank_logger_notification ("Aborted.", "");
		_g_object_unref0 (pixbuf);
		_capture_screen_grabber_unref0 (grabber);
		return;
	}
	_tmp15_ = g_date_time_new_now_local ();
	now = _tmp15_;
	_tmp16_ = _ ("screenshot-");
	_tmp17_ = now;
	_tmp18_ = g_date_time_to_string (_tmp17_);
	_tmp19_ = _tmp18_;
	_tmp20_ = g_strdup_printf ("%s%s.%s", _tmp16_, _tmp19_, "png");
	_tmp21_ = _tmp20_;
	_g_free0 (_tmp19_);
	name = _tmp21_;
	filename = NULL;
	_tmp22_ = self->priv->settings;
	_tmp23_ = g_settings_get_boolean (_tmp22_, "auto-save");
	if (_tmp23_) {
		GSettings* _tmp24_ = NULL;
		gchar* _tmp25_ = NULL;
		gchar* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		gchar* _tmp28_ = NULL;
		_tmp24_ = self->priv->settings;
		_tmp25_ = g_settings_get_string (_tmp24_, "destination");
		_tmp26_ = _tmp25_;
		_tmp27_ = name;
		_tmp28_ = g_build_path (G_DIR_SEPARATOR_S, _tmp26_, _tmp27_, NULL);
		_g_free0 (filename);
		filename = _tmp28_;
		_g_free0 (_tmp26_);
	} else {
		GtkFileChooserDialog* chooser = NULL;
		const gchar* _tmp29_ = NULL;
		GtkFileChooserDialog* _tmp30_ = NULL;
		GtkFileChooserDialog* _tmp31_ = NULL;
		const gchar* _tmp32_ = NULL;
		GtkFileChooserDialog* _tmp33_ = NULL;
		gint _tmp34_ = 0;
		GtkFileChooserDialog* _tmp37_ = NULL;
		_tmp29_ = _ ("Select destination to save the capture");
		_tmp30_ = (GtkFileChooserDialog*) gtk_file_chooser_dialog_new (_tmp29_, NULL, GTK_FILE_CHOOSER_ACTION_SAVE, "_Cancel", GTK_RESPONSE_CANCEL, "_Save", GTK_RESPONSE_ACCEPT, NULL);
		g_object_ref_sink (_tmp30_);
		chooser = _tmp30_;
		_tmp31_ = chooser;
		_tmp32_ = name;
		gtk_file_chooser_set_current_name ((GtkFileChooser*) _tmp31_, _tmp32_);
		_tmp33_ = chooser;
		_tmp34_ = gtk_dialog_run ((GtkDialog*) _tmp33_);
		if (_tmp34_ == ((gint) GTK_RESPONSE_ACCEPT)) {
			GtkFileChooserDialog* _tmp35_ = NULL;
			gchar* _tmp36_ = NULL;
			_tmp35_ = chooser;
			_tmp36_ = gtk_file_chooser_get_filename ((GtkFileChooser*) _tmp35_);
			_g_free0 (filename);
			filename = _tmp36_;
		}
		_tmp37_ = chooser;
		gtk_widget_destroy ((GtkWidget*) _tmp37_);
		_g_object_unref0 (chooser);
	}
	_tmp38_ = filename;
	if (_tmp38_ != NULL) {
		const gchar* _tmp39_ = NULL;
		gchar* _tmp40_ = NULL;
		gchar* _tmp41_ = NULL;
		_tmp39_ = filename;
		_tmp40_ = g_strdup_printf ("Saving Screenshot to %s", _tmp39_);
		_tmp41_ = _tmp40_;
		plank_logger_notification (_tmp41_, "");
		_g_free0 (_tmp41_);
		{
			GdkPixbuf* _tmp42_ = NULL;
			const gchar* _tmp43_ = NULL;
			GSettings* _tmp44_ = NULL;
			gboolean _tmp45_ = FALSE;
			_tmp42_ = pixbuf;
			_tmp43_ = filename;
			gdk_pixbuf_save (_tmp42_, _tmp43_, "png", &_inner_error_, NULL);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch0_g_error;
			}
			_tmp44_ = self->priv->settings;
			_tmp45_ = g_settings_get_boolean (_tmp44_, "show-notifications");
			if (_tmp45_) {
				NotifyNotification* notification = NULL;
				const gchar* _tmp46_ = NULL;
				NotifyNotification* _tmp47_ = NULL;
				NotifyNotification* _tmp48_ = NULL;
				GdkPixbuf* _tmp49_ = NULL;
				NotifyNotification* _tmp50_ = NULL;
				GAppInfo* appinfo = NULL;
				GAppInfo* _tmp51_ = NULL;
				GAppInfo* _tmp52_ = NULL;
				const gchar* _tmp53_ = NULL;
				GAppInfo* _tmp54_ = NULL;
				const gchar* _tmp55_ = NULL;
				GList* files = NULL;
				const gchar* _tmp56_ = NULL;
				GFile* _tmp57_ = NULL;
				GAppInfo* _tmp58_ = NULL;
				GList* _tmp59_ = NULL;
				_tmp46_ = filename;
				_tmp47_ = notify_notification_new ("Screenshot has been saved", _tmp46_, "dialog-information");
				notification = _tmp47_;
				_tmp48_ = notification;
				_tmp49_ = pixbuf;
				notify_notification_set_image_from_pixbuf (_tmp48_, _tmp49_);
				_tmp50_ = notification;
				notify_notification_show (_tmp50_, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (notification);
					goto __catch0_g_error;
				}
				_tmp51_ = g_app_info_get_default_for_type ("image/png", TRUE);
				appinfo = _tmp51_;
				_tmp52_ = appinfo;
				_tmp53_ = g_app_info_get_name (_tmp52_);
				plank_logger_notification (_tmp53_, "");
				_tmp54_ = appinfo;
				_tmp55_ = g_app_info_get_commandline (_tmp54_);
				plank_logger_notification (_tmp55_, "");
				files = NULL;
				_tmp56_ = filename;
				_tmp57_ = g_file_new_for_path (_tmp56_);
				files = g_list_append (files, _tmp57_);
				_tmp58_ = appinfo;
				_tmp59_ = files;
				g_app_info_launch (_tmp58_, _tmp59_, NULL, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					__g_list_free__g_object_unref0_0 (files);
					_g_object_unref0 (appinfo);
					_g_object_unref0 (notification);
					goto __catch0_g_error;
				}
				__g_list_free__g_object_unref0_0 (files);
				_g_object_unref0 (appinfo);
				_g_object_unref0 (notification);
			}
		}
		goto __finally0;
		__catch0_g_error:
		{
			GError* e = NULL;
			GError* _tmp60_ = NULL;
			const gchar* _tmp61_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp60_ = e;
			_tmp61_ = _tmp60_->message;
			g_warning ("CaptureDockItem.vala:267: %s", _tmp61_);
			_g_error_free0 (e);
		}
		__finally0:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (filename);
			_g_free0 (name);
			_g_date_time_unref0 (now);
			_g_object_unref0 (pixbuf);
			_capture_screen_grabber_unref0 (grabber);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp62_ = self->priv->settings;
	_tmp63_ = g_settings_get_boolean (_tmp62_, "copy-to-clipboard");
	if (_tmp63_) {
		GtkClipboard* _tmp64_ = NULL;
		GdkPixbuf* _tmp65_ = NULL;
		_tmp64_ = self->priv->clipboard;
		_tmp65_ = pixbuf;
		gtk_clipboard_set_image (_tmp64_, _tmp65_);
	}
	_g_free0 (filename);
	_g_free0 (name);
	_g_date_time_unref0 (now);
	_g_object_unref0 (pixbuf);
	_capture_screen_grabber_unref0 (grabber);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		CaptureCaptureDockItem* self;
		self = _data1_->self;
		_capture_screen_grabber_unref0 (_data1_->grabber);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean __lambda26_ (Block1Data* _data1_) {
	CaptureCaptureDockItem* self;
	gboolean result = FALSE;
	gdouble _tmp0_ = 0.0;
	gint _tmp1_ = 0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	CaptureSequence* _tmp6_ = NULL;
	CaptureScreenGrabber* _tmp7_ = NULL;
	GdkRectangle* _tmp8_ = NULL;
	GdkPixbuf* _tmp9_ = NULL;
	GdkPixbuf* _tmp10_ = NULL;
	gboolean _tmp11_ = FALSE;
	self = _data1_->self;
	_tmp0_ = _data1_->duration;
	_tmp1_ = _data1_->framerate;
	_data1_->duration = _tmp0_ + (1.0 / ((gdouble) _tmp1_));
	_tmp2_ = _data1_->duration;
	plank_dock_item_set_Count ((PlankDockItem*) self, (gint64) ((gint) _tmp2_));
	_tmp3_ = _data1_->duration;
	_tmp4_ = g_strdup_printf ("Shooting a frame...%.3f", _tmp3_);
	_tmp5_ = _tmp4_;
	plank_logger_notification (_tmp5_, "");
	_g_free0 (_tmp5_);
	_tmp6_ = self->priv->sequence;
	_tmp7_ = _data1_->grabber;
	_tmp8_ = self->priv->selection;
	_tmp9_ = capture_screen_grabber_grab (_tmp7_, _tmp8_);
	_tmp10_ = _tmp9_;
	capture_sequence_add (_tmp6_, _tmp10_);
	_g_object_unref0 (_tmp10_);
	_tmp11_ = self->priv->capturing;
	if (_tmp11_ == FALSE) {
		CaptureCapturePreview* preview = NULL;
		CaptureSequence* _tmp12_ = NULL;
		CaptureCapturePreview* _tmp13_ = NULL;
		gint response = 0;
		CaptureCapturePreview* _tmp14_ = NULL;
		gint _tmp15_ = 0;
		CaptureCapturePreview* _tmp16_ = NULL;
		gint _tmp17_ = 0;
		_tmp12_ = self->priv->sequence;
		_tmp13_ = capture_capture_preview_new (_tmp12_);
		g_object_ref_sink (_tmp13_);
		preview = _tmp13_;
		_tmp14_ = preview;
		_tmp15_ = gtk_dialog_run ((GtkDialog*) _tmp14_);
		response = _tmp15_;
		_tmp16_ = preview;
		gtk_widget_destroy ((GtkWidget*) _tmp16_);
		_tmp17_ = response;
		if (_tmp17_ == ((gint) GTK_RESPONSE_ACCEPT)) {
			GtkFileChooserDialog* file_chooser = NULL;
			GtkFileChooserDialog* _tmp18_ = NULL;
			GtkFileChooserDialog* _tmp19_ = NULL;
			gint _tmp20_ = 0;
			gchar* filename = NULL;
			GtkFileChooserDialog* _tmp21_ = NULL;
			gchar* _tmp22_ = NULL;
			GtkFileChooserDialog* _tmp23_ = NULL;
			gint _tmp24_ = 0;
			_tmp18_ = (GtkFileChooserDialog*) gtk_file_chooser_dialog_new ("Save", NULL, GTK_FILE_CHOOSER_ACTION_SAVE, "Cancel", GTK_RESPONSE_CANCEL, "Save", GTK_RESPONSE_ACCEPT, NULL);
			g_object_ref_sink (_tmp18_);
			file_chooser = _tmp18_;
			_tmp19_ = file_chooser;
			_tmp20_ = gtk_dialog_run ((GtkDialog*) _tmp19_);
			response = _tmp20_;
			_tmp21_ = file_chooser;
			_tmp22_ = gtk_file_chooser_get_filename ((GtkFileChooser*) _tmp21_);
			filename = _tmp22_;
			_tmp23_ = file_chooser;
			gtk_widget_destroy ((GtkWidget*) _tmp23_);
			_tmp24_ = response;
			if (_tmp24_ == ((gint) GTK_RESPONSE_ACCEPT)) {
				CaptureSequence* _tmp25_ = NULL;
				const gchar* _tmp26_ = NULL;
				_tmp25_ = self->priv->sequence;
				_tmp26_ = filename;
				capture_sequence_save_to_animated_gif (_tmp25_, _tmp26_);
			}
			_g_free0 (filename);
			_g_object_unref0 (file_chooser);
		}
		plank_dock_item_set_CountVisible ((PlankDockItem*) self, FALSE);
		result = FALSE;
		_g_object_unref0 (preview);
		return result;
	}
	result = TRUE;
	return result;
}


static gboolean ___lambda26__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda26_ (self);
	return result;
}


void capture_capture_dock_item_take_screencapture (CaptureCaptureDockItem* self, CaptureScreenGrabMode mode) {
	Block1Data* _data1_;
	CaptureSequence* _tmp0_ = NULL;
	CaptureSequence* _tmp1_ = NULL;
	GSettings* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	CaptureScreenGrabMode _tmp5_ = 0;
	GSettings* _tmp21_ = NULL;
	gint _tmp22_ = 0;
	gint _tmp23_ = 0;
	gchar* _tmp24_ = NULL;
	gchar* _tmp25_ = NULL;
	gint _tmp26_ = 0;
	g_return_if_fail (self != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = capture_sequence_new ();
	_capture_sequence_unref0 (self->priv->sequence);
	self->priv->sequence = _tmp0_;
	_tmp1_ = self->priv->sequence;
	_tmp2_ = self->priv->settings;
	_tmp3_ = g_settings_get_int (_tmp2_, "framerate");
	_tmp4_ = CLAMP (_tmp3_, 1, 30);
	capture_sequence_set_framerate (_tmp1_, (guint) _tmp4_);
	_tmp5_ = mode;
	switch (_tmp5_) {
		case CAPTURE_SCREEN_GRAB_MODE_REGION:
		{
			CaptureRegionSelect* region_select = NULL;
			CaptureRegionSelect* _tmp6_ = NULL;
			GtkResponseType response = 0;
			CaptureRegionSelect* _tmp7_ = NULL;
			GtkResponseType _tmp8_ = 0;
			CaptureRegionSelect* _tmp9_ = NULL;
			GtkResponseType _tmp10_ = 0;
			CaptureRegionSelect* _tmp11_ = NULL;
			GdkRectangle _tmp12_ = {0};
			GdkRectangle* _tmp13_ = NULL;
			GSettings* _tmp14_ = NULL;
			gboolean _tmp15_ = FALSE;
			CaptureScreenGrabber* _tmp16_ = NULL;
			_tmp6_ = capture_region_select_new ();
			g_object_ref_sink (_tmp6_);
			region_select = _tmp6_;
			_tmp7_ = region_select;
			_tmp8_ = capture_region_select_run (_tmp7_);
			response = _tmp8_;
			_tmp9_ = region_select;
			gtk_widget_destroy ((GtkWidget*) _tmp9_);
			_tmp10_ = response;
			if (_tmp10_ == GTK_RESPONSE_CANCEL) {
				_g_object_unref0 (region_select);
				block1_data_unref (_data1_);
				_data1_ = NULL;
				return;
			}
			_tmp11_ = region_select;
			capture_region_select_get_selection (_tmp11_, &_tmp12_);
			_tmp13_ = __gdk_rectangle_dup0 (&_tmp12_);
			_g_free0 (self->priv->selection);
			self->priv->selection = _tmp13_;
			_tmp14_ = self->priv->settings;
			_tmp15_ = g_settings_get_boolean (_tmp14_, "include-pointer");
			_tmp16_ = capture_screen_grabber_new (CAPTURE_SCREEN_GRAB_MODE_REGION, _tmp15_);
			_capture_screen_grabber_unref0 (_data1_->grabber);
			_data1_->grabber = _tmp16_;
			_g_object_unref0 (region_select);
			break;
		}
		default:
		{
			CaptureScreenGrabMode _tmp17_ = 0;
			GSettings* _tmp18_ = NULL;
			gboolean _tmp19_ = FALSE;
			CaptureScreenGrabber* _tmp20_ = NULL;
			_tmp17_ = mode;
			_tmp18_ = self->priv->settings;
			_tmp19_ = g_settings_get_boolean (_tmp18_, "include-pointer");
			_tmp20_ = capture_screen_grabber_new (_tmp17_, _tmp19_);
			_capture_screen_grabber_unref0 (_data1_->grabber);
			_data1_->grabber = _tmp20_;
			break;
		}
	}
	_tmp21_ = self->priv->settings;
	_tmp22_ = g_settings_get_int (_tmp21_, "framerate");
	_data1_->framerate = _tmp22_;
	_tmp23_ = _data1_->framerate;
	_tmp24_ = g_strdup_printf ("Framerate is %d", _tmp23_);
	_tmp25_ = _tmp24_;
	plank_logger_notification (_tmp25_, "");
	_g_free0 (_tmp25_);
	self->priv->capturing = TRUE;
	_data1_->duration = (gdouble) 0;
	plank_dock_item_set_CountVisible ((PlankDockItem*) self, TRUE);
	_tmp26_ = _data1_->framerate;
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) (1000 / _tmp26_), ___lambda26__gsource_func, block1_data_ref (_data1_), block1_data_unref);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


static PlankAnimationType capture_capture_dock_item_real_on_scrolled (PlankDockElement* base, GdkScrollDirection dir, GdkModifierType mod, guint32 event_time) {
	CaptureCaptureDockItem * self;
	PlankAnimationType result = 0;
	CaptureCaptureMode _tmp0_ = 0;
	self = (CaptureCaptureDockItem*) base;
	_tmp0_ = self->priv->capture_mode;
	switch (_tmp0_) {
		case CAPTURE_CAPTURE_MODE_SCREENSHOT:
		{
			capture_capture_dock_item_switch_capture_mode (self, CAPTURE_CAPTURE_MODE_SCREENCAST);
			break;
		}
		case CAPTURE_CAPTURE_MODE_SCREENCAST:
		{
			capture_capture_dock_item_switch_capture_mode (self, CAPTURE_CAPTURE_MODE_SCREENSHOT);
			break;
		}
		default:
		{
			capture_capture_dock_item_switch_capture_mode (self, CAPTURE_CAPTURE_MODE_SCREENSHOT);
			break;
		}
	}
	result = PLANK_ANIMATION_TYPE_NONE;
	return result;
}


static PlankAnimationType capture_capture_dock_item_real_on_clicked (PlankDockElement* base, PlankPopupButton button, GdkModifierType mod, guint32 event_time) {
	CaptureCaptureDockItem * self;
	PlankAnimationType result = 0;
	PlankPopupButton _tmp0_ = 0;
	self = (CaptureCaptureDockItem*) base;
	_tmp0_ = button;
	if (_tmp0_ == PLANK_POPUP_BUTTON_LEFT) {
		gboolean _tmp1_ = FALSE;
		_tmp1_ = self->priv->capturing;
		if (!_tmp1_) {
			CaptureCaptureMode _tmp2_ = 0;
			_tmp2_ = self->priv->capture_mode;
			switch (_tmp2_) {
				case CAPTURE_CAPTURE_MODE_SCREENSHOT:
				{
					CaptureScreenGrabMode _tmp3_ = 0;
					_tmp3_ = CAPTURE_SCREEN_GRAB_MODE_REGION;
					capture_capture_dock_item_take_screenshot (self, &_tmp3_);
					break;
				}
				case CAPTURE_CAPTURE_MODE_SCREENCAST:
				{
					capture_capture_dock_item_take_screencapture (self, CAPTURE_SCREEN_GRAB_MODE_REGION);
					break;
				}
				default:
				break;
			}
		} else {
			self->priv->capturing = FALSE;
		}
		result = PLANK_ANIMATION_TYPE_BOUNCE;
		return result;
	}
	result = PLANK_ANIMATION_TYPE_NONE;
	return result;
}


CaptureCaptureDockItem* capture_capture_dock_item_construct (GType object_type) {
	CaptureCaptureDockItem * self = NULL;
	self = (CaptureCaptureDockItem*) plank_docklet_item_construct (object_type);
	return self;
}


CaptureCaptureDockItem* capture_capture_dock_item_new (void) {
	return capture_capture_dock_item_construct (CAPTURE_TYPE_CAPTURE_DOCK_ITEM);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static GObject * capture_capture_dock_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	CaptureCaptureDockItem * self;
	PlankLogLevel _tmp0_ = 0;
	PlankLogLevel _tmp1_ = 0;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	GdkAtom _tmp4_ = 0U;
	GtkClipboard* _tmp5_ = NULL;
	GtkClipboard* _tmp6_ = NULL;
	GSettings* _tmp7_ = NULL;
	GSettings* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	GQuark _tmp12_ = 0U;
	static GQuark _tmp11_label0 = 0;
	static GQuark _tmp11_label1 = 0;
	parent_class = G_OBJECT_CLASS (capture_capture_dock_item_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CAPTURE_TYPE_CAPTURE_DOCK_ITEM, CaptureCaptureDockItem);
	setlocale (LC_MESSAGES, "");
	textdomain (GETTEXT_PACKAGE);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "utf-8");
	bindtextdomain (GETTEXT_PACKAGE, "./po");
	plank_logger_initialize ("capture");
	_tmp0_ = plank_logger_get_DisplayLevel ();
	_tmp1_ = _tmp0_;
	plank_logger_set_DisplayLevel (PLANK_LOG_LEVEL_NOTIFY);
	_tmp2_ = _ ("This is the Capture Docklet");
	plank_logger_notification (_tmp2_, "");
	plank_dock_item_set_Icon ((PlankDockItem*) self, "camera-video");
	_tmp3_ = _ ("Capture something");
	plank_dock_element_set_Text ((PlankDockElement*) self, _tmp3_);
	notify_init ("Capture Docklet");
	_tmp4_ = gdk_atom_intern ("CLIPBOARD", TRUE);
	_tmp5_ = gtk_clipboard_get (_tmp4_);
	_tmp6_ = _g_object_ref0 (_tmp5_);
	_g_object_unref0 (self->priv->clipboard);
	self->priv->clipboard = _tmp6_;
	self->priv->mode = CAPTURE_SCREEN_GRAB_MODE_DESKTOP;
	_g_free0 (self->priv->selection);
	self->priv->selection = NULL;
	_tmp7_ = g_settings_new ("de.hannenz.capture");
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp7_;
	_tmp8_ = self->priv->settings;
	_tmp9_ = g_settings_get_string (_tmp8_, "mode");
	_tmp10_ = _tmp9_;
	_tmp12_ = (NULL == _tmp10_) ? 0 : g_quark_from_string (_tmp10_);
	g_free (_tmp10_);
	if (_tmp12_ == ((0 != _tmp11_label0) ? _tmp11_label0 : (_tmp11_label0 = g_quark_from_static_string ("Screenshot")))) {
		switch (0) {
			default:
			{
				capture_capture_dock_item_switch_capture_mode (self, CAPTURE_CAPTURE_MODE_SCREENSHOT);
				break;
			}
		}
	} else if (_tmp12_ == ((0 != _tmp11_label1) ? _tmp11_label1 : (_tmp11_label1 = g_quark_from_static_string ("Screencast")))) {
		switch (0) {
			default:
			{
				capture_capture_dock_item_switch_capture_mode (self, CAPTURE_CAPTURE_MODE_SCREENCAST);
				break;
			}
		}
	}
	return obj;
}


static void capture_capture_dock_item_class_init (CaptureCaptureDockItemClass * klass) {
	capture_capture_dock_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (CaptureCaptureDockItemPrivate));
	((PlankDockElementClass *) klass)->get_menu_items = capture_capture_dock_item_real_get_menu_items;
	((PlankDockElementClass *) klass)->on_scrolled = capture_capture_dock_item_real_on_scrolled;
	((PlankDockElementClass *) klass)->on_clicked = capture_capture_dock_item_real_on_clicked;
	G_OBJECT_CLASS (klass)->constructor = capture_capture_dock_item_constructor;
	G_OBJECT_CLASS (klass)->finalize = capture_capture_dock_item_finalize;
}


static void capture_capture_dock_item_instance_init (CaptureCaptureDockItem * self) {
	self->priv = CAPTURE_CAPTURE_DOCK_ITEM_GET_PRIVATE (self);
	self->priv->capturing = FALSE;
}


static void capture_capture_dock_item_finalize (GObject* obj) {
	CaptureCaptureDockItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CAPTURE_TYPE_CAPTURE_DOCK_ITEM, CaptureCaptureDockItem);
	_g_object_unref0 (self->priv->clipboard);
	_g_free0 (self->priv->selection);
	_capture_sequence_unref0 (self->priv->sequence);
	_g_object_unref0 (self->priv->settings);
	G_OBJECT_CLASS (capture_capture_dock_item_parent_class)->finalize (obj);
}


GType capture_capture_dock_item_get_type (void) {
	static volatile gsize capture_capture_dock_item_type_id__volatile = 0;
	if (g_once_init_enter (&capture_capture_dock_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CaptureCaptureDockItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) capture_capture_dock_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CaptureCaptureDockItem), 0, (GInstanceInitFunc) capture_capture_dock_item_instance_init, NULL };
		GType capture_capture_dock_item_type_id;
		capture_capture_dock_item_type_id = g_type_register_static (PLANK_TYPE_DOCKLET_ITEM, "CaptureCaptureDockItem", &g_define_type_info, 0);
		g_once_init_leave (&capture_capture_dock_item_type_id__volatile, capture_capture_dock_item_type_id);
	}
	return capture_capture_dock_item_type_id__volatile;
}



